<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>zszBlog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="zszBlog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="zszBlog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="zszBlog">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="zszBlog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">zszBlog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="q" value="site:http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2015-6-5-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/06/05/2015-6-5-2/" class="article-date">
  <time datetime="2015-06-05T03:06:22.000Z" itemprop="datePublished">2015-06-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/05/2015-6-5-2/">java集合的使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java集合">Java集合</h1><p>java集合接口（接口不能直接实例化、要实例化他的子类）：</p>
<ul>
<li>Collection 接口</li>
<li>List接口</li>
<li>Set接口</li>
<li>Iterator接口</li>
<li>Map接口</li>
</ul>
<h2 id="接口之间的关系图">接口之间的关系图</h2><p><img src="http://cl.ly/image/1F3P3E42350q/IC$HBD%601%7BZ2A%60S3K]L@C05V.png" alt="接口之间关系"></p>
<h2 id="集合">集合</h2><ul>
<li>1.集合可以理解为一个动态的对象数组，不同的是集合的对象内容可以任意扩充</li>
<li>2.集合的特点：<br> 性能高，容易扩展和修改<h2 id="List接口">List接口</h2>List继承自Collection</li>
<li>1.List接口可以存放任意的数据，而且在List接口中内容是可以重复的</li>
<li>2.List接口常用子类</li>
<li><ul>
<li>Arraylist</li>
<li>Vector</li>
</ul>
</li>
</ul>
<p>Arraylist和Vector的实现差不多，他们之间的区别就是</p>
<ul>
<li>Arraylist：采用异步处理方式，性能高，属于非线程安全。</li>
<li>Vector：采用同步处理方式，性能低，属于线程安全。</li>
</ul>
<p>ArrayList的简单实例</p>
<pre><code><span class="keyword">import</span> java.util.ArrayList;
<span class="keyword">import</span> java.util.List;

<span class="keyword">public</span> class ListTest {

<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) {
    <span class="comment">// TODO Auto-generated method stub</span>

    <span class="comment">//List是一个接口，必须实例化其子类。</span>
    List&lt;<span class="keyword">String</span>&gt; list=<span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;();
    <span class="comment">//集合使用add添加</span>
    list.<span class="built_in">add</span>(<span class="string">"添加字符串"</span>);
    list.<span class="built_in">add</span>(<span class="string">"A"</span>);
    list.<span class="built_in">add</span>(<span class="string">"B"</span>);
    list.<span class="built_in">add</span>(<span class="string">"C"</span>);

    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;list.<span class="built_in">size</span>(); i++) {
        <span class="comment">//集合使用get方法来获取元素内容。</span>
        System.out.<span class="built_in">println</span>(list.<span class="built_in">get</span>(i));
    }
    <span class="comment">//remove删除操作</span>
    list.remove(<span class="number">0</span>);
    System.out.<span class="built_in">println</span>(<span class="string">"删除后的操作"</span>);
    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; list.<span class="built_in">size</span>(); i++) {
        System.out.<span class="built_in">println</span>(list.<span class="built_in">get</span>(i));
    }
    System.out.<span class="built_in">println</span>(<span class="string">"判断集合是否为空"</span>+list.isEmpty());
    <span class="comment">//indexOf返回值是元素的位置。</span>
    System.out.<span class="built_in">println</span>(<span class="string">"判断元素是否存在，例如C: "</span>+list.indexOf(<span class="string">"C"</span>));
}

}
</code></pre><h2 id="Set接口">Set接口</h2><ul>
<li>1.Set接口中不能加入重复元素，但是可以排序</li>
<li>2.常用子类：HashSet 和TreeSet </li>
</ul>
<p>HashSet：无順序性，查找速度快<br>（注意相同多个D，set只会读取一个）<br>TreeSet：有排序性(依字母)，由紅黑樹所建 </p>
<pre><code>import java.util.TreeSet;

public class SetTest {

public static void main(String[] args) {
    // TODO Auto-generated method stub

//        <span class="operator"><span class="keyword">Set</span>&lt;<span class="keyword">String</span>&gt; <span class="keyword">set</span>=new HashSet&lt;<span class="keyword">String</span>&gt;();</span>
    <span class="operator"><span class="keyword">Set</span>&lt;<span class="keyword">String</span>&gt; <span class="keyword">set</span>=new TreeSet&lt;<span class="keyword">String</span>&gt;();</span>
    <span class="operator"><span class="keyword">set</span>.<span class="keyword">add</span>(<span class="string">"2"</span>);</span>
    <span class="operator"><span class="keyword">set</span>.<span class="keyword">add</span>(<span class="string">"4"</span>);</span>
    <span class="operator"><span class="keyword">set</span>.<span class="keyword">add</span>(<span class="string">"1"</span>);</span>
    <span class="operator"><span class="keyword">set</span>.<span class="keyword">add</span>(<span class="string">"31"</span>);</span>
    <span class="operator"><span class="keyword">set</span>.<span class="keyword">add</span>(<span class="string">"a"</span>);</span>
    <span class="operator"><span class="keyword">set</span>.<span class="keyword">add</span>(<span class="string">"D"</span>);</span>
    <span class="operator"><span class="keyword">set</span>.<span class="keyword">add</span>(<span class="string">"D"</span>);</span>

    System.out.println(<span class="operator"><span class="keyword">set</span>);</span>
}

}
</code></pre><h2 id="Iterator接口">Iterator接口</h2><p>1.集合输出的标准操作：标准做法，使用Iterator接口<br>2.操作原理：Iterator是专门的迭代输出接口，迭代输出就是将元素一个个进行判断，判断其是否有内容，如果有内容则把内容取出。</p>
<p>Iterator的实例化比较特别：是通过集合来获得他的一个对象，来实例化。</p>
<p>hasNext()：判断集合中元素是否遍历完毕，如果没有，就返回true<br>next() ：返回下一个元素 </p>
<pre><code>package com.zsz.develop;

<span class="keyword">import</span> java.util.<span class="type">ArrayList</span>;
<span class="keyword">import</span> java.util.<span class="type">Iterator</span>;
<span class="keyword">import</span> java.util.<span class="type">List</span>;

public class <span class="type">IteratorTest</span> {

public <span class="keyword">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args) {
    // <span class="type">TODO</span> <span class="type">Auto</span>-generated <span class="keyword">method</span> stub

    <span class="type">List</span>&lt;<span class="type">Integer</span>&gt; list=new <span class="type">ArrayList</span>&lt;<span class="type">Integer</span>&gt;();
    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {
        list.add(i);

    }
    //使用<span class="type">Iterator</span>标准输出格式来输出
    <span class="type">Iterator</span>&lt;<span class="type">Integer</span>&gt; <span class="keyword">iterator</span>=list.<span class="keyword">iterator</span>();
    <span class="keyword">while</span> (<span class="keyword">iterator</span>.hasNext()) {
        <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="keyword">iterator</span>.next());
    }
}

}
</code></pre><h2 id="Map接口">Map接口</h2><p>1.保存形式：是以Key—value对的方式来保存<br>2.常用子类</p>
<ul>
<li>HashMap：无序存放，KEY不允许重复、</li>
<li>Hashtable：无序存放，KEY不允许重复、</li>
</ul>
<p>在list，set中添加数据都是使用add，而map是使用put添加数据。<br>通过map.get（）可以得到Key中的Value。</p>
<p>要得到所以的键：Map.keySet() 返回类型是set&lt;&gt;;<br>要得到所以的值：Map.Value 返回类型是Collection&lt;&gt;;</p>
<p>map实例</p>
<pre><code>package com.zsz.develop;

<span class="keyword">import</span> java.util.<span class="type">Collection</span>;
<span class="keyword">import</span> java.util.<span class="type">HashMap</span>;
<span class="keyword">import</span> java.util.<span class="type">Iterator</span>;
<span class="keyword">import</span> java.util.<span class="type">Map</span>;
<span class="keyword">import</span> java.util.<span class="type">Set</span>;

public class <span class="type">MapTest</span> {

public <span class="keyword">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args) {
    // <span class="type">TODO</span> <span class="type">Auto</span>-generated <span class="keyword">method</span> stub

    //键值对的形式来存储数据
    <span class="type">Map</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; map=new <span class="type">HashMap</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt;();
    map.put(<span class="string">"key1"</span>, <span class="string">"first"</span>);
    map.put(<span class="string">"key2"</span>, <span class="string">"first2"</span>);
    map.put(<span class="string">"key3"</span>, <span class="string">"first3"</span>);
    map.put(<span class="string">"key4"</span>, <span class="string">"first4"</span>);

    //得到所以的键
    <span class="type">Set</span>&lt;<span class="type">String</span>&gt; <span class="type">set</span>=map.keySet();
    <span class="type">Iterator</span>&lt;<span class="type">String</span>&gt; <span class="keyword">iterator</span>=<span class="type">set</span>.<span class="keyword">iterator</span>();
    <span class="keyword">while</span> (<span class="keyword">iterator</span>.hasNext()) {
        <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="keyword">iterator</span>.next());
    }

    <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"上面为全部键，下面为全部值"</span>);
    //得到所有的值
    <span class="type">Collection</span>&lt;<span class="type">String</span>&gt; collection=map.values();
    <span class="type">Iterator</span>&lt;<span class="type">String</span>&gt; i=collection.<span class="keyword">iterator</span>();
    <span class="keyword">while</span> (i.hasNext()) {
        <span class="type">System</span>.<span class="keyword">out</span>.println(i.next());

    }

    //判断是否存在键
    <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"是否存在键： "</span>+map.containsKey(<span class="string">"key1"</span>));
    //判断是否存在值
    <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"是否存在值： "</span>+map.containsKey(<span class="string">"first1"</span>));

}


}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/06/05/2015-6-5-2/" data-id="ciajapx4o0003qsb2kov6bl4y" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2015-6-5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/06/04/2015-6-5/" class="article-date">
  <time datetime="2015-06-04T13:40:35.000Z" itemprop="datePublished">2015-06-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/04/2015-6-5/">SharedPrefenences的使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="SharedPrefenences是什么">SharedPrefenences是什么</h1><p>SharedPrefenences是一种轻型的数据存储方式，他的本质是基于XML文件存储<strong>Ket-Value键值对数据</strong>，通常用来存储一些简单的<strong>配置信息</strong>。</p>
<p>存储位置在/data/data/&lt;包名&gt;/shared_prefs目录下。</p>
<p>SharedPrefenences对象本身只能获取数据而<strong>不支持存储和修改，存储修改要通过Editor对象实现。</strong></p>
<h1 id="SharedPrefenences的优势">SharedPrefenences的优势</h1><p>SharedPrefenences与SQLite数据库相比，免去了创建数据库，创建表，写SQL语句等操作，更加易用。</p>
<p>支持的类型数据</p>
<ul>
<li>boolean</li>
<li>int</li>
<li>float</li>
<li>long</li>
<li>String</li>
</ul>
<p>但是无法进行条件查询。</p>
<h1 id="SharedPrefenences的代码实现">SharedPrefenences的代码实现</h1><p>Activity：</p>
<pre><code><span class="keyword">package</span> com.zsz.develop.sharedpreferencestest;

<span class="keyword">import</span> android.content.SharedPreferences;
<span class="keyword">import</span> android.support.v7.app.ActionBarActivity;
<span class="keyword">import</span> android.os.Bundle;
<span class="keyword">import</span> android.view.Menu;
<span class="keyword">import</span> android.view.MenuItem;
<span class="keyword">import</span> android.view.View;
<span class="keyword">import</span> android.widget.EditText;
<span class="keyword">import</span> android.widget.Toast;


<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">ActionBarActivity</span> </span>{

<span class="keyword">private</span> EditText etData;
<span class="keyword">private</span>  SharedPreferences sharedPreferences;
<span class="annotation">@Override</span>
<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{
    <span class="keyword">super</span>.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    etData= (EditText) findViewById(R.id.etData);
    sharedPreferences=getSharedPreferences(<span class="string">"sharedPrefXML"</span>,MODE_PRIVATE);
    <span class="comment">//要编辑修改sharedPreferences就要使用Editor来修改</span>
   <span class="keyword">final</span> SharedPreferences.Editor editor= sharedPreferences.edit();

    <span class="comment">//读取SharedPreferences数据</span>
    findViewById(R.id.btnRead).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() {
        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>{

            <span class="comment">//得到sharedPreferences的值,传进去第一个参数是键，第二个是如果为空返回的值。</span>
          String value=  sharedPreferences.getString(<span class="string">"key-name"</span>,<span class="string">"当前数值不存在"</span>);
            Toast.makeText(getApplicationContext(),value,Toast.LENGTH_SHORT).show();
        }
    });

    <span class="comment">//写入SharedPreferences数据</span>
    findViewById(R.id.btnWrite).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() {
        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>{

            <span class="comment">//要修改存储什么类型数据就put什么类型,这里传进去的是Key-Value</span>
            editor.putString(<span class="string">"key-name"</span>,etData.getText().toString().trim());
            <span class="comment">//commit提交数据,commit返回值为boolean。进行判断</span>
          <span class="keyword">if</span> (editor.commit()) {
              Toast.makeText(getApplicationContext(), <span class="string">"写入成功"</span>, Toast.LENGTH_SHORT).show();
          }
        }
    });



}



}
</code></pre><p>layout档：</p>
<pre><code>&lt;LinearLayout xmlns:<span class="variable">android=</span><span class="string">"http://schemas.android.com/apk/res/android"</span>
xmlns:<span class="variable">tools=</span><span class="string">"http://schemas.android.com/tools"</span> android:<span class="variable">layout_width=</span><span class="string">"match_parent"</span>
android:<span class="variable">layout_height=</span><span class="string">"match_parent"</span>
android:<span class="variable">orientation=</span><span class="string">"vertical"</span>&gt;
&lt;EditText
   android:<span class="variable">layout_width=</span><span class="string">"fill_parent"</span>
   android:<span class="variable">layout_height=</span><span class="string">"wrap_content"</span>
   android:<span class="variable">id=</span><span class="string">"@+id/etData"</span>
   /&gt;
&lt;Button
    android:<span class="variable">layout_width=</span><span class="string">"fill_parent"</span>
    android:<span class="variable">layout_height=</span><span class="string">"wrap_content"</span>
    android:<span class="variable">id=</span><span class="string">"@+id/btnRead"</span>
    android:<span class="variable">text=</span><span class="string">"读取数据"</span>
    /&gt;

&lt;Button
    android:<span class="variable">layout_width=</span><span class="string">"fill_parent"</span>
    android:<span class="variable">layout_height=</span><span class="string">"wrap_content"</span>
    android:<span class="variable">id=</span><span class="string">"@+id/btnWrite"</span>
    android:<span class="variable">text=</span><span class="string">"写入数据"</span>
    /&gt;
&lt;/LinearLayout&gt;
</code></pre><p>SharedPrefenences非常方便的使用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/06/04/2015-6-5/" data-id="ciajapx4m0002qsb20nnuiezg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2015-6-4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/06/04/2015-6-4/" class="article-date">
  <time datetime="2015-06-04T08:03:24.000Z" itemprop="datePublished">2015-06-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/04/2015-6-4/">清除用户数据</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="清除用户数据">清除用户数据</h1><p>非常实用的清空数据函数。</p>
<p>主要通过deleteFilesByDirectory（）函数删除文件，来达到清楚数据的功能。</p>
<p>功能有清除内/外缓存，清除数据库，清除sharedPreference，清除files和清除自定义目录</p>
<pre><code>package com.fsd.zsz.manplan.main;

/<span class="keyword">*</span><span class="keyword">*</span>
 <span class="keyword">*</span> Created by shengzhong on 2015/6/3.
 <span class="keyword">*</span>/


import java.io.File;
import android.content.Context;
import android.os.Environment;
/<span class="keyword">*</span><span class="keyword">*</span> <span class="keyword">*</span> 本应用数据清除管理器 <span class="keyword">*</span>/
public class DataCleanManager {
    /<span class="keyword">*</span><span class="keyword">*</span> <span class="keyword">*</span> 清除本应用内部缓存(/data/data/com.xxx.xxx/cache) <span class="keyword">*</span> <span class="keyword">*</span> <span class="comment">@param context */</span>
    public static void cleanInternalCache(Context context) {
        deleteFilesByDirectory(context.getCacheDir());
    }
    /<span class="keyword">*</span><span class="keyword">*</span> <span class="keyword">*</span> 清除本应用所有数据库(/data/data/com.xxx.xxx/databases) <span class="keyword">*</span> <span class="keyword">*</span> <span class="comment">@param context */</span>
    public static void cleanDatabases(Context context) {
        deleteFilesByDirectory(new File(<span class="string">"/data/data/"</span>
                + context.getPackageName() + <span class="string">"/databases"</span>));
    }
    /<span class="keyword">*</span><span class="keyword">*</span>
     <span class="keyword">*</span> <span class="keyword">*</span> 清除本应用SharedPreference(/data/data/com.xxx.xxx/shared_prefs) <span class="keyword">*</span> <span class="keyword">*</span> <span class="comment">@param</span>
     <span class="keyword">*</span> context
     <span class="keyword">*</span>/
    public static void cleanSharedPreference(Context context) {
        deleteFilesByDirectory(new File(<span class="string">"/data/data/"</span>
                + context.getPackageName() + <span class="string">"/shared_prefs"</span>));
    }
    /<span class="keyword">*</span><span class="keyword">*</span> <span class="keyword">*</span> 按名字清除本应用数据库 <span class="keyword">*</span> <span class="keyword">*</span> <span class="comment">@param context * @param dbName */</span>
    public static void cleanDatabaseByName(Context context, String dbName) {
        context.deleteDatabase(dbName);
    }
    /<span class="keyword">*</span><span class="keyword">*</span> <span class="keyword">*</span> 清除/data/data/com.xxx.xxx/files下的内容 <span class="keyword">*</span> <span class="keyword">*</span> <span class="comment">@param context */</span>
    public static void cleanFiles(Context context) {
        deleteFilesByDirectory(context.getFilesDir());
    }
    /<span class="keyword">*</span><span class="keyword">*</span>
     <span class="keyword">*</span> <span class="keyword">*</span> 清除外部cache下的内容(/mnt/sdcard/android/data/com.xxx.xxx/cache) <span class="keyword">*</span> <span class="keyword">*</span> <span class="comment">@param</span>
     <span class="keyword">*</span> context
     <span class="keyword">*</span>/
    public static void cleanExternalCache(Context context) {
        if (Environment.getExternalStorageState().equals(
                Environment.MEDIA_MOUNTED)) {
            deleteFilesByDirectory(context.getExternalCacheDir());
        }
    }
    /<span class="keyword">*</span><span class="keyword">*</span> <span class="keyword">*</span> 清除自定义路径下的文件，使用需小心，请不要误删。而且只支持目录下的文件删除 <span class="keyword">*</span> <span class="keyword">*</span> <span class="comment">@param filePath */</span>
    public static void cleanCustomCache(String filePath) {
        deleteFilesByDirectory(new File(filePath));
    }
    /<span class="keyword">*</span><span class="keyword">*</span> <span class="keyword">*</span> 清除本应用所有的数据 <span class="keyword">*</span> <span class="keyword">*</span> <span class="comment">@param context * @param filepath */</span>
    public static void cleanApplicationData(Context context, String... filepath) {
        cleanInternalCache(context);
        cleanExternalCache(context);
        cleanDatabases(context);
        cleanSharedPreference(context);
        cleanFiles(context);
        for (String filePath : filepath) {
            cleanCustomCache(filePath);
        }
    }
    /<span class="keyword">*</span><span class="keyword">*</span> <span class="keyword">*</span> 删除方法 这里只会删除某个文件夹下的文件，如果传入的directory是个文件，将不做处理 <span class="keyword">*</span> <span class="keyword">*</span> <span class="comment">@param directory */</span>
    private static void deleteFilesByDirectory(File directory) {
        if (directory != null &amp;&amp; directory.exists() &amp;&amp; directory.isDirectory()) {
            for (File item : directory.listFiles()) {
                item.delete();
            }
        }
    }
}
</code></pre><p>出处：<a href="http://blog.csdn.net/berber78/article/details/38587567" target="_blank" rel="external">http://blog.csdn.net/berber78/article/details/38587567</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/06/04/2015-6-4/" data-id="ciajapx4q0004qsb2e3qxw48s" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2015-5-31" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/05/31/2015-5-31/" class="article-date">
  <time datetime="2015-05-31T11:51:39.000Z" itemprop="datePublished">2015-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/31/2015-5-31/">Android设置日期与时间</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Android设置日期与时间">Android设置日期与时间</h1><p>取得设置系统时间是Android非常实用的一个功能</p>
<h2 id="取得系统时间">取得系统时间</h2><p>实例化Calendar时，他已经默认的设置了系统时间。<br>setTimeInMillis（）这个方法，会根据你传入的毫秒数对日历对象中的变量进行相应设置。System.currentTimeMillis()可以得到系统到距离1970年1月1日0时的毫秒数</p>
<pre><code>      <span class="comment">//Calendar定义日历对象</span>
<span class="keyword">private</span> Calendar calendar;
    <span class="comment">//实例化日历对象</span>
    calendar=Calendar.getInstance();
    <span class="comment">//设置系统时间</span>
    calendar.setTimeInMillis(System.currentTimeMillis());
    <span class="comment">//得到系统时间</span>
   <span class="keyword">final</span> Date time=calendar.getTime();
    <span class="comment">//得到时和分</span>
   <span class="keyword">final</span> <span class="built_in">int</span> <span class="built_in">hour</span>= calendar.<span class="built_in">get</span>(Calendar.HOUR_OF_DAY);
    <span class="keyword">final</span> <span class="built_in">int</span> <span class="built_in">minute</span>=calendar.<span class="built_in">get</span>(Calendar.MINUTE);
</code></pre><h2 id="时间选择器">时间选择器</h2><p>时间选择器：<br>TimePickerDialog(Contextcontext,TimePickerDialog.OnTimeSetListenercallBack, int hourOfDay, int minute, boolean is24HourView)</p>
<ul>
<li><p>其中TimePickerDialog.OnTimeSetListenercallBack是用户选择好时间后，通知应用的回调函数。监听用户更改时间参数，调用的方法。</p>
</li>
<li><p>is24HourView选择是否为24小时制</p>
</li>
<li></li>
</ul>
<pre><code>tvTime= (TextView) findViewById(R.id.tvTime);
   tvTime.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() {
       <span class="annotation">@Override</span>
       <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>{
           <span class="keyword">new</span> TimePickerDialog(MainActivity.<span class="keyword">this</span>,<span class="keyword">new</span> TimePickerDialog.OnTimeSetListener() {
               <span class="annotation">@Override</span>
               <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onTimeSet</span><span class="params">(TimePicker timePicker, <span class="keyword">int</span> i, <span class="keyword">int</span> i2)</span> </span>{
                   tvTime.setText(<span class="string">"shi"</span>+i+<span class="string">"fen"</span>+i2);
               }
           },<span class="number">10</span>,<span class="number">20</span>,<span class="keyword">true</span>).show();
       }
   });
</code></pre><h2 id="日期选择器">日期选择器</h2><p>同理时间选择器</p>
<pre><code>tvDate= (TextView) findViewById(R.id.tvDate);
   tvDate.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() {
       <span class="annotation">@Override</span>
       <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>{

           <span class="keyword">new</span> DatePickerDialog(MainActivity.<span class="keyword">this</span>, <span class="keyword">new</span> DatePickerDialog.OnDateSetListener() {
               <span class="annotation">@Override</span>
               <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onDateSet</span><span class="params">(DatePicker view, <span class="keyword">int</span> year, <span class="keyword">int</span> monthOfYear, <span class="keyword">int</span> dayOfMonth)</span> </span>{

                   tvDate.setText(String.format(<span class="string">"%d:%d:%d"</span>,year,monthOfYear,dayOfMonth));
               }

           },<span class="number">2015</span>,<span class="number">6</span>,<span class="number">2</span>).show();
       }
   });
</code></pre><p>Layout档</p>
<pre><code>   &lt;TextView
    android:<span class="variable">layout_width=</span><span class="string">"wrap_content"</span>
    android:<span class="variable">layout_height=</span><span class="string">"wrap_content"</span>
    android:<span class="variable">text=</span><span class="string">"0000:00:00"</span>
    android:<span class="variable">id=</span><span class="string">"@+id/tvDate"</span>
    /&gt;

&lt;TextView
    android:<span class="variable">layout_width=</span><span class="string">"wrap_content"</span>
    android:<span class="variable">layout_height=</span><span class="string">"wrap_content"</span>
    android:<span class="variable">text=</span><span class="string">"00:00:00"</span>
    android:<span class="variable">id=</span><span class="string">"@+id/tvTime"</span>
    /&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/05/31/2015-5-31/" data-id="ciajapx4s0005qsb2dre4sazn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2015-5-27" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/05/27/2015-5-27/" class="article-date">
  <time datetime="2015-05-27T13:14:38.000Z" itemprop="datePublished">2015-05-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/27/2015-5-27/">Android 非同步任務 - AsyncTask</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Android_非同步任務_-_AsyncTask">Android 非同步任務 - AsyncTask</h1><h2 id="Android为什么要使用多线程">Android为什么要使用多线程</h2><ul>
<li>提高用户体验或者避免ANR（如果在主线程（UI线程）操作一些耗时的操作容易造成卡顿<br>android 规定主线程中不可以做http 连接操作。）</li>
<li>异步</li>
<li>多任务</li>
</ul>
<p>当主线程（UI线程）操作到一些复杂的IO操作（文件操作，网络操作，数据库操作），复杂运算等耗时操作，容易造成卡顿。</p>
<p>应用程序弹出“无响应”的对话框（ANR），那是因为在Android主线程中进行了超时的操作，过多的阻塞了主线程就会导致应用出现ANR的Waring。(android 规定主线程中不可以做http 连接操作)</p>
<h2 id="AsyncTask是什么">AsyncTask是什么</h2><p>  AsyncTask,是android提供的輕量級的非同步類,可以直接繼承AsyncTask,在類中實現非同步操作,並提供介面反饋當前非同步執行的程度(可以通過介面實現UI進度更新),最後反饋執行的結果給UI主線程.</p>
<h2 id="为什么使用AsyncTask">为什么使用AsyncTask</h2><ul>
<li>AsyncTask能实现多线程，避免ANR</li>
<li>简单快捷易操作</li>
<li>过程可控</li>
</ul>
<h2 id="AsyncTask怎么使用">AsyncTask怎么使用</h2><p>AsyncTask定义了三种泛型类型 Params，Progress和Result。<br>Params 启动任务执行的输入参数，比如HTTP请求的URL。<br>Progress 后台任务执行的百分比。<br>Result 后台执行任务最终返回的结果，比如String。 </p>
<pre><code>`private class <span class="type">TestAsyncTask</span> extends <span class="type">AsyncTask</span>&lt;<span class="type">String</span>, <span class="type">Void</span>, <span class="type">Boolean</span>&gt; 

{

 @<span class="type">Override</span>
  protected <span class="type">void</span> onPreExecute() 
  {
    //最先执行的就是这个。一遍添加进度条
 }

  @<span class="type">Override</span>
  protected <span class="type">Boolean</span> doInBackground(<span class="type">String</span>... params)
  {
    //这个是在后台执行的东西，就是说，它自动另外开了个线程运行，不影响你现在做的东西。
    //复杂的<span class="type">IO</span>操作（文件操作，网络操作，数据库操作），复杂运算等耗时操作
 }


@<span class="type">Override</span>
  protected <span class="type">void</span> onPostExecute(<span class="type">Boolean</span> <span class="literal">result</span>)
  {
    <span class="keyword">if</span> (<span class="literal">result</span>)
    {
      //后台执行的完毕后，它会用<span class="type">Result</span>通知这里，就是执行这里了。
  }
    <span class="keyword">else</span>
    {
      //所以最好判断一下<span class="literal">result</span>，写个<span class="keyword">else</span>，判断后台执行的东西是不是出问题了。
  }
  }
}`
</code></pre><p><a href="http://yuchen.blog.51cto.com/2739238/593019" title="如何在Android中用好多线程" target="_blank" rel="external">http://yuchen.blog.51cto.com/2739238/593019</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/05/27/2015-5-27/" data-id="ciajapx4u0006qsb2cbagc1s5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2015-5-24" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/05/24/2015-5-24/" class="article-date">
  <time datetime="2015-05-24T14:08:39.000Z" itemprop="datePublished">2015-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/24/2015-5-24/">Dao模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="DAO模式">DAO模式</h2><p>信息系统的架构分为：</p>
<p>客户层———-显示层———-业务层————-数据层————-数据库</p>
<ul>
<li>1.客户层：客户层就是客户端，简单的来说就是浏览器。</li>
<li>2.显示层：JSP/Servlet，用于给浏览器显示。</li>
<li>3.业务层：对于数据层的原子操作进行整合。（Dao）</li>
<li>4.数据层：对于数据库进行的原子操作，增加、删除等；（DaoImpl）</li>
</ul>
<p>说直白点就是定义了一个接口（Dao），让（DaoImpl）去实现这个接口。</p>
<h2 id="Dao层包含的类">Dao层包含的类</h2><p>DAO层一般有接口和该接口的实现类！</p>
<ul>
<li>接口用于规范实现类！</li>
<li>实现类一般用于用于操作数据库！ 一般操作修改，添加，删除数据库操作的步骤很相似，就写了一个公共类DAO类 ，修改，添加，删除数据库操作时 直接调用公共类DAO类！</li>
</ul>
<h2 id="为什么使用Dao">为什么使用Dao</h2><p>Dao是接口，他的优势就是接口的优势。</p>
<p>接口作为系统与外界交互的窗口，接口体现是一种规范。</p>
<p>对于接口的实现者而言，接口规定了实现者必须向外提供哪些服务(以方法的形式来提供)；</p>
<p>对于接口调用者而言，接口规定了调用者可以调用哪些服务，以及如何调用这些服务（就是如何来调用方法的）。</p>
<p>当一个程序中使用接口时，接口是多个模块之间的耦合标准；</p>
<p>当多个应用程序之间使用时，接口时多个程序之间的通信标准。</p>
<p>从某种程度来说，接口类型整个系统中的“总纲”，它制定了系统之间各个模块应该遵循的标准，因此一个系统中的接口不应该经常改变。一旦接口改变，对整个系统<br>甚至其他系统的影响将是辐射式的，导致系统中大部分类需要重写。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/05/24/2015-5-24/" data-id="ciajapx4w0007qsb23h66rp98" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2015-5-17" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/05/17/2015-5-17/" class="article-date">
  <time datetime="2015-05-17T11:14:59.000Z" itemprop="datePublished">2015-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/17/2015-5-17/">jsp两种设计模型 </a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="jsp两种设计模型">jsp两种设计模型</h1><ul>
<li>jsp+javaBean</li>
<li>jsp+javaBean+Servlet</li>
</ul>
<p>其实还有第三种，纯粹用jsp来编写。由jsp来处理业务逻辑，显示页面，控制流程。由于这种代码繁琐，可重复性差、不易于维护所以很快被市场抛弃了</p>
<h2 id="jsp+javaBean">jsp+javaBean</h2><p>页面显示和业务逻辑处理分开，JSP实现页面显示，JavaBean对象用来保存数据和实现商业逻辑</p>
<p> 工作原理是：当浏览器发出请求时，jsp接受请求并访问javabean。若需要访问数据库后台服务器，则通过javaBean连接数据库或后台服务器，执行相应的处理。javaBean将处理的结果数据交给jsp。jsp提取结果并重新组织后，动态生成HRML页面，返回给浏览器。用户从浏览器显示的页面中得到交互的结果</p>
<h2 id="jsp+javaBean+Servlet">jsp+javaBean+Servlet</h2><p>把流程控制代码和部分的逻辑处理代码提取到servlet中去。</p>
<p>mvc架构：model层  +view层 controller层</p>
<ul>
<li>model：实现业务逻辑，包括了web应用程序功能的核心，负责存储与<br>应用程序相关的数据</li>
<li>view：用于用户的页面显示，他可以访问model层数据，但不能更改这些数据</li>
<li>Controller：主要负责model和view的控制关系，负责处理http的请求等</li>
</ul>
<p>并不是说mvc架构就更好。<br>根据实际来选择：</p>
<ul>
<li>当事务逻辑比较负责、分支较多或需要涉及很多JavaBean组件时，由于JSP和JavaBean+Servlet模型比JSP和JavaBean模型有更清晰的页面表现、更明确的开发模块的划分，所以使用JSP和JavaBean+Servlet模型比较适合</li>
<li>对于简单的交互处理，利用JSP和JavaBean模型，JSP主要是使用HTML工具开发，然后再插入少量的Java代码就可以实现动态交互。在这种情况下，使用JSP和JavaBean模型更加方便快捷</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/05/17/2015-5-17/" data-id="ciajapx4y0008qsb2u251qg0c" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2015-5-16" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/05/16/2015-5-16/" class="article-date">
  <time datetime="2015-05-16T13:30:35.000Z" itemprop="datePublished">2015-05-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/16/2015-5-16/">jsp九大内置对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="jsp九大内置对象">jsp九大内置对象</h1><ul>
<li>out 输出对象</li>
<li>request 请求对象</li>
<li>reponse 响应对象</li>
<li>session 会话层对象</li>
<li>application 应用层对象</li>
<li>config 配置对象</li>
<li>page 页面对象 </li>
<li>pageContext  页面上下文对象</li>
<li>Exception 异常对象</li>
</ul>
<h2 id="为什么要有内置对象">为什么要有内置对象</h2><p>因为这九大对象在jsp中使用太平繁，为了简化操作就事先内置在jsp中。程序员们就可以不用每次都去实例化操作。</p>
<p>（程序编写的绝大部分原因都是为了提高效率）</p>
<h2 id="out_（page）">out （page）</h2><p>out最常用的对象之一，代表了向客户端发送数据对象。</p>
<h2 id="request_（request）">request （request）</h2><p>request 是客户端向服务器发出的请求。</p>
<p>通过getParameter、getParameterNames和getParameterValues方法来获取请求对象中所包含的参数的值。</p>
<p>也可以设置其属性值，setAttribute与getAttribute方法这两个方法先设置后取得。所以他们一般都是同时出现</p>
<p>request的作用域只有在请求时，当请求结束时，得到响应后就销毁</p>
<h2 id="response_（page）">response （page）</h2><p>response代表对客户端的响应。但一般比较少用，使用out直接输出</p>
<h2 id="session（session）">session（session）</h2><p>session代表服务器与客户端所建立的会话。<br>一个完整的会话是：从客户端连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。</p>
<p>根据这个特性，session可以实现在线购物，密码安全等保存客户端状态信息操作</p>
<h2 id="application（application）">application（application）</h2><p>application负责提供应用程序在服务器中运行时的一些全局信息。根据这个特性，他能实现浏览计数器</p>
<h2 id="config（page）">config（page）</h2><h2 id="page（page）">page（page）</h2><h2 id="pageContext（page）">pageContext（page）</h2><h2 id="Exception（page）">Exception（page）</h2><p>括号中的为作用域<br>剩下的以后用到的时候再谈。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/05/16/2015-5-16/" data-id="ciajapx520009qsb23b39a5ju" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2015-5-15" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/05/15/2015-5-15/" class="article-date">
  <time datetime="2015-05-15T13:01:21.000Z" itemprop="datePublished">2015-05-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/15/2015-5-15/">web工作原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Web的工作原理">Web的工作原理</h1><blockquote>
<p>行业发展趋势：</p>
<p>先有客户端迁移到<strong>移动端</strong></p>
<p>再由移动端迁移到<strong>浏览器</strong></p>
</blockquote>
<p>随着云计算的迅速发展，网络速度的不断加快，浏览器的不断强大。云计算的普及已经越来越深入人心。这将会带来更大的发展空间，人们在网页上实现更多的操作。这也意味着未来十年内将迎来网页端的再一次高潮。</p>
<p>我们这一代是最差的一代，似乎所有挣钱的行业都被抢占完了。<br>但我们这一代也是最幸运的一代，我们已经明确的知道了解网页端的开发能给我们带来的就业前景。</p>
<p>这时候、我们必须赶在这一波潮流之前学好web开发</p>
<p>这里粗略的讲解一下</p>
<p>web：分成server端（服务器）和client（客户端）他们要通过浏览器进行传输数据，浏览器必须要支持http协议。</p>
<h2 id="web的工作原理：">web的工作原理：</h2><ul>
<li><p>1.建立连接</p>
</li>
<li><p>2.client通过浏览器向server端发送request</p>
</li>
<li><p>3.server再response返回给client</p>
</li>
<li><p>4.关闭连接</p>
</li>
</ul>
<h2 id="server是怎么处理client发送上来的请求的呢">server是怎么处理client发送上来的请求的呢</h2><ul>
<li>server创建一个servlet的实例（调用init（））；</li>
<li>client的请求到达server；</li>
<li>server将请求发送给servlet；</li>
<li>servlet生成对应请求的相应；</li>
<li>server激活Servlet的service()方法，传递请求和响应对象作为参数；</li>
</ul>
<h2 id="server是如何创建servlet的呢？">server是如何创建servlet的呢？</h2><p>通过jsp页面，也就是包含静态的html代码和动态的java程序以及其他脚本写在一起的页面，最终通过servlet容器编译成完servlet类（java类）。</p>
<p>现在我们一般使用Tomcat作为servlet的容器。在我们执行jsp后进行第一次执行时。tomcat就先将jsp转化为了servlet</p>
<p>重复一边jsp和servlet和tomcat<br>jsp：是一个带有java程序的html<br>servlet：是一个jsp执行后的java类<br>tomcat：是执行这个编译的容器</p>
<p>其中的具体实现以后慢慢分享</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/05/15/2015-5-15/" data-id="ciajapx2h0000qsb2w82wkk3m" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-First-Blog" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/05/14/First-Blog/" class="article-date">
  <time datetime="2015-05-14T12:36:21.000Z" itemprop="datePublished">2015-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/14/First-Blog/">First Blog</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="这是我的新博客">这是我的新博客</h2><h2 id="为什么要创建博客">为什么要创建博客</h2><ul>
<li>对学习进行归纳总结</li>
<li>纵观全局，对所学的知识扩散</li>
<li>写博客的资源都源于网络，是我加以整理归纳得来。经过多方比对，一番思考，能加深我对问题的理解</li>
<li><p>分享，收获最大的是自己</p>
<h2 id="怎么写好博客">怎么写好博客</h2></li>
<li><p>学习实践中遇到的问题，记录下来。</p>
</li>
<li>抽取时间，系统研究他的原理</li>
<li>不盲从，不瞎编</li>
<li>自己真正理解了再写博客</li>
</ul>
<blockquote>
<p>人和人的差距源至业余时间。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/05/14/First-Blog/" data-id="ciajapx4b0001qsb28d0a4xo0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a><span class="archive-list-count">7</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/06/05/2015-6-5-2/">java集合的使用</a>
          </li>
        
          <li>
            <a href="/2015/06/04/2015-6-5/">SharedPrefenences的使用</a>
          </li>
        
          <li>
            <a href="/2015/06/04/2015-6-4/">清除用户数据</a>
          </li>
        
          <li>
            <a href="/2015/05/31/2015-5-31/">Android设置日期与时间</a>
          </li>
        
          <li>
            <a href="/2015/05/27/2015-5-27/">Android 非同步任務 - AsyncTask</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>