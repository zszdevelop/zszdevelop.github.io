<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>zszBlog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="zszBlog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="zszBlog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="zszBlog">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="zszBlog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">zszBlog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="q" value="site:http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2015-5-31" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/05/31/2015-5-31/" class="article-date">
  <time datetime="2015-05-31T11:51:39.000Z" itemprop="datePublished">2015-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/31/2015-5-31/">Android设置日期与时间</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Android设置日期与时间">Android设置日期与时间</h1><p>取得设置系统时间是Android非常实用的一个功能</p>
<h2 id="取得系统时间">取得系统时间</h2><p>实例化Calendar时，他已经默认的设置了系统时间。<br>setTimeInMillis（）这个方法，会根据你传入的毫秒数对日历对象中的变量进行相应设置。System.currentTimeMillis()可以得到系统到距离1970年1月1日0时的毫秒数</p>
<pre><code>      <span class="comment">//Calendar定义日历对象</span>
<span class="keyword">private</span> Calendar calendar;
    <span class="comment">//实例化日历对象</span>
    calendar=Calendar.getInstance();
    <span class="comment">//设置系统时间</span>
    calendar.setTimeInMillis(System.currentTimeMillis());
    <span class="comment">//得到系统时间</span>
   <span class="keyword">final</span> Date time=calendar.getTime();
    <span class="comment">//得到时和分</span>
   <span class="keyword">final</span> <span class="built_in">int</span> <span class="built_in">hour</span>= calendar.<span class="built_in">get</span>(Calendar.HOUR_OF_DAY);
    <span class="keyword">final</span> <span class="built_in">int</span> <span class="built_in">minute</span>=calendar.<span class="built_in">get</span>(Calendar.MINUTE);
</code></pre><h2 id="日期选择器">日期选择器</h2><pre><code>tvDate= (TextView) findViewById(R.id.tvDate);
   tvDate.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() {
       <span class="annotation">@Override</span>
       <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>{

           <span class="keyword">new</span> DatePickerDialog(MainActivity.<span class="keyword">this</span>, <span class="keyword">new</span> DatePickerDialog.OnDateSetListener() {
               <span class="annotation">@Override</span>
               <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onDateSet</span><span class="params">(DatePicker view, <span class="keyword">int</span> year, <span class="keyword">int</span> monthOfYear, <span class="keyword">int</span> dayOfMonth)</span> </span>{

                   tvDate.setText(String.format(<span class="string">"%d:%d:%d"</span>,year,monthOfYear,dayOfMonth));
               }

           },<span class="number">2015</span>,<span class="number">6</span>,<span class="number">2</span>).show();
       }
   });
</code></pre><h2 id="时间选择器">时间选择器</h2><pre><code>tvTime= (TextView) findViewById(R.id.tvTime);
   tvTime.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() {
       <span class="annotation">@Override</span>
       <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>{
           <span class="keyword">new</span> TimePickerDialog(MainActivity.<span class="keyword">this</span>,<span class="keyword">new</span> TimePickerDialog.OnTimeSetListener() {
               <span class="annotation">@Override</span>
               <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onTimeSet</span><span class="params">(TimePicker timePicker, <span class="keyword">int</span> i, <span class="keyword">int</span> i2)</span> </span>{
                   tvTime.setText(<span class="string">"shi"</span>+i+<span class="string">"fen"</span>+i2);
               }
           },<span class="number">10</span>,<span class="number">20</span>,<span class="keyword">true</span>).show();
       }
   });
</code></pre><p>Layout档</p>
<pre><code>   &lt;TextView
    android:<span class="variable">layout_width=</span><span class="string">"wrap_content"</span>
    android:<span class="variable">layout_height=</span><span class="string">"wrap_content"</span>
    android:<span class="variable">text=</span><span class="string">"0000:00:00"</span>
    android:<span class="variable">id=</span><span class="string">"@+id/tvDate"</span>
    /&gt;

&lt;TextView
    android:<span class="variable">layout_width=</span><span class="string">"wrap_content"</span>
    android:<span class="variable">layout_height=</span><span class="string">"wrap_content"</span>
    android:<span class="variable">text=</span><span class="string">"00:00:00"</span>
    android:<span class="variable">id=</span><span class="string">"@+id/tvTime"</span>
    /&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/05/31/2015-5-31/" data-id="ciahw9bqc0002p4b2n4zmmj3h" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2015-5-27" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/05/27/2015-5-27/" class="article-date">
  <time datetime="2015-05-27T13:14:38.000Z" itemprop="datePublished">2015-05-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/27/2015-5-27/">Android 非同步任務 - AsyncTask</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Android_非同步任務_-_AsyncTask">Android 非同步任務 - AsyncTask</h1><h2 id="Android为什么要使用多线程">Android为什么要使用多线程</h2><ul>
<li>提高用户体验或者避免ANR（如果在主线程（UI线程）操作一些耗时的操作容易造成卡顿<br>android 规定主线程中不可以做http 连接操作。）</li>
<li>异步</li>
<li>多任务</li>
</ul>
<p>当主线程（UI线程）操作到一些复杂的IO操作（文件操作，网络操作，数据库操作），复杂运算等耗时操作，容易造成卡顿。</p>
<p>应用程序弹出“无响应”的对话框（ANR），那是因为在Android主线程中进行了超时的操作，过多的阻塞了主线程就会导致应用出现ANR的Waring。(android 规定主线程中不可以做http 连接操作)</p>
<h2 id="AsyncTask是什么">AsyncTask是什么</h2><p>  AsyncTask,是android提供的輕量級的非同步類,可以直接繼承AsyncTask,在類中實現非同步操作,並提供介面反饋當前非同步執行的程度(可以通過介面實現UI進度更新),最後反饋執行的結果給UI主線程.</p>
<h2 id="为什么使用AsyncTask">为什么使用AsyncTask</h2><ul>
<li>AsyncTask能实现多线程，避免ANR</li>
<li>简单快捷易操作</li>
<li>过程可控</li>
</ul>
<h2 id="AsyncTask怎么使用">AsyncTask怎么使用</h2><p>AsyncTask定义了三种泛型类型 Params，Progress和Result。<br>Params 启动任务执行的输入参数，比如HTTP请求的URL。<br>Progress 后台任务执行的百分比。<br>Result 后台执行任务最终返回的结果，比如String。 </p>
<pre><code>`private class <span class="type">TestAsyncTask</span> extends <span class="type">AsyncTask</span>&lt;<span class="type">String</span>, <span class="type">Void</span>, <span class="type">Boolean</span>&gt; 

{

 @<span class="type">Override</span>
  protected <span class="type">void</span> onPreExecute() 
  {
    //最先执行的就是这个。一遍添加进度条
 }

  @<span class="type">Override</span>
  protected <span class="type">Boolean</span> doInBackground(<span class="type">String</span>... params)
  {
    //这个是在后台执行的东西，就是说，它自动另外开了个线程运行，不影响你现在做的东西。
    //复杂的<span class="type">IO</span>操作（文件操作，网络操作，数据库操作），复杂运算等耗时操作
 }


@<span class="type">Override</span>
  protected <span class="type">void</span> onPostExecute(<span class="type">Boolean</span> <span class="literal">result</span>)
  {
    <span class="keyword">if</span> (<span class="literal">result</span>)
    {
      //后台执行的完毕后，它会用<span class="type">Result</span>通知这里，就是执行这里了。
  }
    <span class="keyword">else</span>
    {
      //所以最好判断一下<span class="literal">result</span>，写个<span class="keyword">else</span>，判断后台执行的东西是不是出问题了。
  }
  }
}`
</code></pre><p><a href="http://yuchen.blog.51cto.com/2739238/593019" title="如何在Android中用好多线程" target="_blank" rel="external">http://yuchen.blog.51cto.com/2739238/593019</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/05/27/2015-5-27/" data-id="ciahw9bqe0003p4b250tdglfx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2015-5-24" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/05/24/2015-5-24/" class="article-date">
  <time datetime="2015-05-24T14:08:39.000Z" itemprop="datePublished">2015-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/24/2015-5-24/">Dao模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="DAO模式">DAO模式</h2><p>信息系统的架构分为：</p>
<p>客户层———-显示层———-业务层————-数据层————-数据库</p>
<ul>
<li>1.客户层：客户层就是客户端，简单的来说就是浏览器。</li>
<li>2.显示层：JSP/Servlet，用于给浏览器显示。</li>
<li>3.业务层：对于数据层的原子操作进行整合。（Dao）</li>
<li>4.数据层：对于数据库进行的原子操作，增加、删除等；（DaoImpl）</li>
</ul>
<p>说直白点就是定义了一个接口（Dao），让（DaoImpl）去实现这个接口。</p>
<h2 id="Dao层包含的类">Dao层包含的类</h2><p>DAO层一般有接口和该接口的实现类！</p>
<ul>
<li>接口用于规范实现类！</li>
<li>实现类一般用于用于操作数据库！ 一般操作修改，添加，删除数据库操作的步骤很相似，就写了一个公共类DAO类 ，修改，添加，删除数据库操作时 直接调用公共类DAO类！</li>
</ul>
<h2 id="为什么使用Dao">为什么使用Dao</h2><p>Dao是接口，他的优势就是接口的优势。</p>
<p>接口作为系统与外界交互的窗口，接口体现是一种规范。</p>
<p>对于接口的实现者而言，接口规定了实现者必须向外提供哪些服务(以方法的形式来提供)；</p>
<p>对于接口调用者而言，接口规定了调用者可以调用哪些服务，以及如何调用这些服务（就是如何来调用方法的）。</p>
<p>当一个程序中使用接口时，接口是多个模块之间的耦合标准；</p>
<p>当多个应用程序之间使用时，接口时多个程序之间的通信标准。</p>
<p>从某种程度来说，接口类型整个系统中的“总纲”，它制定了系统之间各个模块应该遵循的标准，因此一个系统中的接口不应该经常改变。一旦接口改变，对整个系统<br>甚至其他系统的影响将是辐射式的，导致系统中大部分类需要重写。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/05/24/2015-5-24/" data-id="ciahw9bqg0004p4b2l3uvnmhv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2015-5-17" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/05/17/2015-5-17/" class="article-date">
  <time datetime="2015-05-17T11:14:59.000Z" itemprop="datePublished">2015-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/17/2015-5-17/">jsp两种设计模型 </a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="jsp两种设计模型">jsp两种设计模型</h1><ul>
<li>jsp+javaBean</li>
<li>jsp+javaBean+Servlet</li>
</ul>
<p>其实还有第三种，纯粹用jsp来编写。由jsp来处理业务逻辑，显示页面，控制流程。由于这种代码繁琐，可重复性差、不易于维护所以很快被市场抛弃了</p>
<h2 id="jsp+javaBean">jsp+javaBean</h2><p>页面显示和业务逻辑处理分开，JSP实现页面显示，JavaBean对象用来保存数据和实现商业逻辑</p>
<p> 工作原理是：当浏览器发出请求时，jsp接受请求并访问javabean。若需要访问数据库后台服务器，则通过javaBean连接数据库或后台服务器，执行相应的处理。javaBean将处理的结果数据交给jsp。jsp提取结果并重新组织后，动态生成HRML页面，返回给浏览器。用户从浏览器显示的页面中得到交互的结果</p>
<h2 id="jsp+javaBean+Servlet">jsp+javaBean+Servlet</h2><p>把流程控制代码和部分的逻辑处理代码提取到servlet中去。</p>
<p>mvc架构：model层  +view层 controller层</p>
<ul>
<li>model：实现业务逻辑，包括了web应用程序功能的核心，负责存储与<br>应用程序相关的数据</li>
<li>view：用于用户的页面显示，他可以访问model层数据，但不能更改这些数据</li>
<li>Controller：主要负责model和view的控制关系，负责处理http的请求等</li>
</ul>
<p>并不是说mvc架构就更好。<br>根据实际来选择：</p>
<ul>
<li>当事务逻辑比较负责、分支较多或需要涉及很多JavaBean组件时，由于JSP和JavaBean+Servlet模型比JSP和JavaBean模型有更清晰的页面表现、更明确的开发模块的划分，所以使用JSP和JavaBean+Servlet模型比较适合</li>
<li>对于简单的交互处理，利用JSP和JavaBean模型，JSP主要是使用HTML工具开发，然后再插入少量的Java代码就可以实现动态交互。在这种情况下，使用JSP和JavaBean模型更加方便快捷</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/05/17/2015-5-17/" data-id="ciahw9bqi0005p4b2jh0cxigd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2015-5-16" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/05/16/2015-5-16/" class="article-date">
  <time datetime="2015-05-16T13:30:35.000Z" itemprop="datePublished">2015-05-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/16/2015-5-16/">jsp九大内置对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="jsp九大内置对象">jsp九大内置对象</h1><ul>
<li>out 输出对象</li>
<li>request 请求对象</li>
<li>reponse 响应对象</li>
<li>session 会话层对象</li>
<li>application 应用层对象</li>
<li>config 配置对象</li>
<li>page 页面对象 </li>
<li>pageContext  页面上下文对象</li>
<li>Exception 异常对象</li>
</ul>
<h2 id="为什么要有内置对象">为什么要有内置对象</h2><p>因为这九大对象在jsp中使用太平繁，为了简化操作就事先内置在jsp中。程序员们就可以不用每次都去实例化操作。</p>
<p>（程序编写的绝大部分原因都是为了提高效率）</p>
<h2 id="out_（page）">out （page）</h2><p>out最常用的对象之一，代表了向客户端发送数据对象。</p>
<h2 id="request_（request）">request （request）</h2><p>request 是客户端向服务器发出的请求。</p>
<p>通过getParameter、getParameterNames和getParameterValues方法来获取请求对象中所包含的参数的值。</p>
<p>也可以设置其属性值，setAttribute与getAttribute方法这两个方法先设置后取得。所以他们一般都是同时出现</p>
<p>request的作用域只有在请求时，当请求结束时，得到响应后就销毁</p>
<h2 id="response_（page）">response （page）</h2><p>response代表对客户端的响应。但一般比较少用，使用out直接输出</p>
<h2 id="session（session）">session（session）</h2><p>session代表服务器与客户端所建立的会话。<br>一个完整的会话是：从客户端连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。</p>
<p>根据这个特性，session可以实现在线购物，密码安全等保存客户端状态信息操作</p>
<h2 id="application（application）">application（application）</h2><p>application负责提供应用程序在服务器中运行时的一些全局信息。根据这个特性，他能实现浏览计数器</p>
<h2 id="config（page）">config（page）</h2><h2 id="page（page）">page（page）</h2><h2 id="pageContext（page）">pageContext（page）</h2><h2 id="Exception（page）">Exception（page）</h2><p>括号中的为作用域<br>剩下的以后用到的时候再谈。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/05/16/2015-5-16/" data-id="ciahw9bqk0006p4b2cvf77u5r" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2015-5-15" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/05/15/2015-5-15/" class="article-date">
  <time datetime="2015-05-15T13:01:21.000Z" itemprop="datePublished">2015-05-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/15/2015-5-15/">web工作原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Web的工作原理">Web的工作原理</h1><blockquote>
<p>行业发展趋势：</p>
<p>先有客户端迁移到<strong>移动端</strong></p>
<p>再由移动端迁移到<strong>浏览器</strong></p>
</blockquote>
<p>随着云计算的迅速发展，网络速度的不断加快，浏览器的不断强大。云计算的普及已经越来越深入人心。这将会带来更大的发展空间，人们在网页上实现更多的操作。这也意味着未来十年内将迎来网页端的再一次高潮。</p>
<p>我们这一代是最差的一代，似乎所有挣钱的行业都被抢占完了。<br>但我们这一代也是最幸运的一代，我们已经明确的知道了解网页端的开发能给我们带来的就业前景。</p>
<p>这时候、我们必须赶在这一波潮流之前学好web开发</p>
<p>这里粗略的讲解一下</p>
<p>web：分成server端（服务器）和client（客户端）他们要通过浏览器进行传输数据，浏览器必须要支持http协议。</p>
<h2 id="web的工作原理：">web的工作原理：</h2><ul>
<li><p>1.建立连接</p>
</li>
<li><p>2.client通过浏览器向server端发送request</p>
</li>
<li><p>3.server再response返回给client</p>
</li>
<li><p>4.关闭连接</p>
</li>
</ul>
<h2 id="server是怎么处理client发送上来的请求的呢">server是怎么处理client发送上来的请求的呢</h2><ul>
<li>server创建一个servlet的实例（调用init（））；</li>
<li>client的请求到达server；</li>
<li>server将请求发送给servlet；</li>
<li>servlet生成对应请求的相应；</li>
<li>server激活Servlet的service()方法，传递请求和响应对象作为参数；</li>
</ul>
<h2 id="server是如何创建servlet的呢？">server是如何创建servlet的呢？</h2><p>通过jsp页面，也就是包含静态的html代码和动态的java程序以及其他脚本写在一起的页面，最终通过servlet容器编译成完servlet类（java类）。</p>
<p>现在我们一般使用Tomcat作为servlet的容器。在我们执行jsp后进行第一次执行时。tomcat就先将jsp转化为了servlet</p>
<p>重复一边jsp和servlet和tomcat<br>jsp：是一个带有java程序的html<br>servlet：是一个jsp执行后的java类<br>tomcat：是执行这个编译的容器</p>
<p>其中的具体实现以后慢慢分享</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/05/15/2015-5-15/" data-id="ciahw9boh0000p4b203gxvvy9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-First-Blog" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/05/14/First-Blog/" class="article-date">
  <time datetime="2015-05-14T12:36:21.000Z" itemprop="datePublished">2015-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/14/First-Blog/">First Blog</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="这是我的新博客">这是我的新博客</h2><h2 id="为什么要创建博客">为什么要创建博客</h2><ul>
<li>对学习进行归纳总结</li>
<li>纵观全局，对所学的知识扩散</li>
<li>写博客的资源都源于网络，是我加以整理归纳得来。经过多方比对，一番思考，能加深我对问题的理解</li>
<li><p>分享，收获最大的是自己</p>
<h2 id="怎么写好博客">怎么写好博客</h2></li>
<li><p>学习实践中遇到的问题，记录下来。</p>
</li>
<li>抽取时间，系统研究他的原理</li>
<li>不盲从，不瞎编</li>
<li>自己真正理解了再写博客</li>
</ul>
<blockquote>
<p>人和人的差距源至业余时间。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/05/14/First-Blog/" data-id="ciahw9bq20001p4b2g2qk0z0e" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a><span class="archive-list-count">7</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/05/31/2015-5-31/">Android设置日期与时间</a>
          </li>
        
          <li>
            <a href="/2015/05/27/2015-5-27/">Android 非同步任務 - AsyncTask</a>
          </li>
        
          <li>
            <a href="/2015/05/24/2015-5-24/">Dao模式</a>
          </li>
        
          <li>
            <a href="/2015/05/17/2015-5-17/">jsp两种设计模型 </a>
          </li>
        
          <li>
            <a href="/2015/05/16/2015-5-16/">jsp九大内置对象</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>