<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>zszBlog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="this zszdeveloper blog��welcome��">
<meta property="og:type" content="website">
<meta property="og:title" content="zszBlog">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="zszBlog">
<meta property="og:description" content="this zszdeveloper blog��welcome��">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="zszBlog">
<meta name="twitter:description" content="this zszdeveloper blog��welcome��">
  
  
  <link href='//fonts.useso.com/css?family=Open+Sans:400italic,400,600' rel='stylesheet' type='text/css'>
  <link href="//fonts.useso.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css" type="text/css">
  

  
</head>
<body>
  <div id="container">
    <header id="header">
  <div id="header-main" class="header-inner">
    <div class="outer">
      <a href="/" id="logo"><i class="logo"></i><span class="site-title">zszBlog</span></a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/.">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/categories">Categories</a>
        
          <a class="main-nav-link" href="/tags">Tags</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        <div class="profile" id="profile-nav">
          <a id="profile-anchor" href="javascript:;"><img class="avatar" src="http://cl.ly/image/382p262u1E3o/%60IF)_M7]QGJMAK096_$F$$6.png"><i class="fa fa-caret-down"></i></a>
        </div>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"> </button><input type="hidden" name="q" value="site:http://yoursite.com"></form>
      </div>
    </div>
  </div>
  <div id="main-nav-mobile" class="header-sub header-inner">
    <table class="menu outer">
      <tr>
      
        <td><a class="main-nav-link" href="/.">Home</a></td>
      
        <td><a class="main-nav-link" href="/archives">Archives</a></td>
      
        <td><a class="main-nav-link" href="/categories">Categories</a></td>
      
        <td><a class="main-nav-link" href="/tags">Tags</a></td>
      
        <td><a class="main-nav-link" href="/about">About</a></td>
      
      <td>
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="hidden" name="q" value="site:http://yoursite.com"></form>
      </td>
      </tr>
    </table>
  </div>
</header>
    <div class="outer">
      <aside id="profile">
  <div class="inner profile-inner">
  	<div class="base-info profile-block">
		  <img id="avatar" src="http://cl.ly/image/382p262u1E3o/%60IF)_M7]QGJMAK096_$F$$6.png">
      <h2 id="name">zszdevelop</h2>
      <h3 id="title">Java&amp;Android Developer</h3>
      <span id="location"><i class="fa fa-map-marker"></i>XiaMen, China</span>
      <a id="follow" href="undefined">FOLLOW</a>
  	</div>
    <div class="article-info profile-block">
      <div class="article-info-block">
        32
        <span>posts</span>
      </div>
      <div class="article-info-block">
        0
        <span>tag</span>
      </div>
    </div>
    
    <div class="contact-info profile-block">
      <table class="contact-list">
        <tr>
        
          <td><a href="https://github.com/zszdevelop" target="_blank" title="github"><i class="fa fa-github"></i></a></td>
        
          <td><a href="/#" target="_blank" title="twitter"><i class="fa fa-twitter"></i></a></td>
        
          <td><a href="https://www.facebook.com/profile.php?id=100007317255366" target="_blank" title="facebook"><i class="fa fa-facebook"></i></a></td>
        
        </tr>
      </table>
    </div>
    
  </div>
</aside>
      <section id="main">
      <article id="post-2015-7-11" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/11/2015-7-11/">连接数据库代码，为什么静态类方法可以直接调用？，.PreparedStatement和Statement的使用，结果集(ResultSet)用法</a>
    </h1>
  

        <div class="article-meta">
          <div class="article-date">
  <i class="fa fa-calendar"></i>
  <a href="/2015/07/11/2015-7-11/">
    <time datetime="2015-07-11T10:25:33.000Z" itemprop="datePublished">2015-07-11</time>
  </a>
</div>
          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="711问题集">711问题集</h1><ul>
<li>1.The local variable conn may not have been initialized<h2 id="局部变量没有初始化问题？">局部变量没有初始化问题？</h2></li>
</ul>
<p>局部变量在进行读取操作之前必须进行初始化或进行赋值操作,否则会出现编译错误.</p>
<h2 id="-_2-连接数据库代码">- 2.连接数据库代码</h2><pre><code>package com.zsz.develop.util;
<span class="preprocessor"><span class="keyword">import</span> java.sql.Connection;</span>
<span class="preprocessor"><span class="keyword">import</span> java.sql.DriverManager;</span>
<span class="preprocessor"><span class="keyword">import</span> java.sql.SQLException;</span>

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseConnection</span> {</span>

<span class="keyword">public</span> static Connection getConnection(){    

    Connection conn=<span class="literal">null</span>;
    <span class="keyword">try</span> {
        <span class="class"><span class="keyword">Class</span>.<span class="title">forName</span>("<span class="title">com</span>.<span class="title">mysql</span>.<span class="title">jdbc</span>.<span class="title">Driver</span>");</span>
        conn=DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/test"</span>, <span class="string">"root"</span>, <span class="string">"SF948640."</span>);
    } <span class="keyword">catch</span> (ClassNotFoundException e) {
        // TODO Auto-generated <span class="keyword">catch</span> block
        e.printStackTrace();
    } <span class="keyword">catch</span> (SQLException e) {
        // TODO Auto-generated <span class="keyword">catch</span> block
        e.printStackTrace();
    }

    <span class="keyword">return</span> conn;
}

}
</code></pre><h2 id="-_3-为什么静态类方法可以直接调用？">- 3.为什么静态类方法可以直接调用？</h2><p>这是因为静态类方法实际上属于类，不同任何类实例相关，也不允许访问任何实例属性；因此这些方法可以共享，可以直接调用；而普通方法需要同类实例相关，因此必须在对应的实例中访问。</p>
<pre><code>    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
<span class="comment">//当connection成为静态时、就可以直接调用。</span>
<span class="comment">//        Connection conn=new BaseConnection().getConnection();</span>
    Connection conn=BaseConnection.getConnection();
    System.<span class="keyword">out</span>.println(conn);
}
</code></pre><h2 id="-_4-PreparedStatement和Statement的使用">- 4.PreparedStatement和Statement的使用</h2><p>PreparedStatement和Statement都是SQL执行器对象。PreparedStatement 对象已预编译过(所以第一次执行花费更多时间)，所以其执行速度要快于 Statement 对象。</p>
<p>JDBC驱动的最佳化是基于使用的是什么功能. 选择PreparedStatement还是Statement取决于你要怎么使用它们. 对于只执行一次的SQL语句选择Statement是最好的. 相反, 如果SQL语句被多次执行选用PreparedStatement是最好的.</p>
<h2 id="-_5-结果集(ResultSet)用法">- 5.结果集(ResultSet)用法</h2><p>ResultSet，数据库结果集的数据表，通常通过执行查询数据库的语句生成。</p>
<p>ResultSet里面是一个指针数据，他首先指向0位置，也就是标题。当他使用next（）时。他读取的才是真正的数据。然后通过0位置的标题对比逐个取出数据</p>
<p>简单实例</p>
<pre><code>    <span class="function"><span class="keyword">public</span> ArrayList&lt;UserInfoDao&gt; <span class="title">getList</span><span class="params">()</span></span>{
    ArrayList&lt;UserInfoDao&gt; arrayList=<span class="keyword">new</span> ArrayList&lt;UserInfoDao&gt;();
    Connection conn=BaseConnection.getConnection();
    <span class="comment">//sql执行器Statement</span>
    PreparedStatement ps=<span class="keyword">null</span>;
    <span class="comment">//ResultSet结果集对象</span>
    String sql=<span class="string">"select * from userinfo"</span>;
    <span class="keyword">try</span> {
        ps=ps=(PreparedStatement) conn.prepareStatement(sql);
        rs =ps.executeQuery();
        <span class="keyword">while</span> (rs.next()) {
            System.<span class="keyword">out</span>.println(rs.getString(<span class="string">"name"</span>)+<span class="string">"-----"</span>);
        }

    } <span class="keyword">catch</span> (SQLException e) {
        <span class="comment">// TODO Auto-generated catch block</span>
        e.printStackTrace();
    }

    <span class="keyword">return</span> arrayList;
}
</code></pre><p>把他存进实体类，再读取出来的案例</p>
<pre><code>package com.zsz.develop.dao;

<span class="keyword">import</span> java.sql.Connection;
<span class="keyword">import</span> java.sql.ResultSet;
<span class="keyword">import</span> java.sql.SQLException;
<span class="keyword">import</span> java.util.ArrayList;
<span class="keyword">import</span> java.util.Iterator;

<span class="keyword">import</span> com.mysql.jdbc.PreparedStatement;
<span class="keyword">import</span> com.zsz.develop.bean.UserInfo;
<span class="keyword">import</span> com.zsz.develop.util.BaseConnection;

public <span class="class"><span class="keyword">class</span> <span class="title">UserInfoDao</span> </span>{

public ArrayList&lt;UserInfo&gt; getList(){
    ArrayList&lt;UserInfo&gt; arrayList=<span class="keyword">new</span> ArrayList&lt;UserInfo&gt;();
    Connection conn=BaseConnection.getConnection();
    PreparedStatement ps=<span class="literal">null</span>;

    <span class="built_in">String</span> sql=<span class="string">"select * from userinfo"</span>;
    <span class="keyword">try</span> {
        ps=(PreparedStatement) conn.prepareStatement(sql);
        ResultSet rs =ps.executeQuery();
        <span class="keyword">while</span> (rs.next()) {
<span class="comment">//                System.out.println(rs.getString("name")+"-----");</span>
            <span class="comment">//把数据封装到实体类</span>
            UserInfo userInfo=<span class="keyword">new</span> UserInfo();
            userInfo.setId(rs.getInt(<span class="string">"id"</span>));
            userInfo.setName(rs.getString(<span class="string">"name"</span>));
            userInfo.setPassword(rs.getString(<span class="string">"password"</span>));
            <span class="comment">//再把封装好的对象放到我们的集合中去</span>
            arrayList.add(userInfo);
        }

    } <span class="keyword">catch</span> (SQLException e) {
        <span class="comment">// TODO Auto-generated catch block</span>
        e.printStackTrace();
    }

    <span class="keyword">return</span> arrayList;
}
<span class="comment">//添加再其他地方既可以使用。</span>
<span class="comment">//    public static void main(String[] args) {</span>
<span class="comment">//        ArrayList&lt;UserInfo&gt; arrayList= new UserInfoDao().getList();</span>
<span class="comment">//        //用新型for循环把他打印出来</span>
<span class="comment">//        for(UserInfo userInfo:arrayList){</span>
<span class="comment">//            System.out.println(userInfo.getId()+"  "+userInfo.getName()+"  "+userInfo.getPassword());</span>
<span class="comment">//        }</span>
<span class="comment">//    }</span>

}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/07/11/2015-7-11/" data-id="cicznlcoo000misb2e8z8wjq8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


    
      <article id="post-2015-6-8" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/08/2015-6-8/">Android传数据到服务器端</a>
    </h1>
  

        <div class="article-meta">
          <div class="article-date">
  <i class="fa fa-calendar"></i>
  <a href="/2015/06/08/2015-6-8/">
    <time datetime="2015-06-08T07:24:12.000Z" itemprop="datePublished">2015-06-08</time>
  </a>
</div>
          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Android传数据到服务器端">Android传数据到服务器端</h1><p>在之前的博客中提到主线程中不能操作耗时的操作，例如网络操作。</p>
<p>今天使用实例来使用AsnycTask。</p>
<pre><code> public <span class="type">Robot</span> query(<span class="type">Robot</span> rqRobot) {

    <span class="type">Gson</span> gson=<span class="keyword">new</span> <span class="type">Gson</span><span class="literal">()</span>;
    <span class="type">String</span> url= <span class="type">MyData</span>.<span class="type">URL</span>+<span class="string">"RobotServlet"</span>;
    <span class="type">HttpClient</span> client=<span class="keyword">new</span> <span class="type">DefaultHttpClient</span><span class="literal">()</span>;
    <span class="type">HttpPost</span> post=<span class="keyword">new</span> <span class="type">HttpPost</span>(url);
    <span class="type">List</span>&lt;<span class="type">NameValuePair</span>&gt; rqParmeter=<span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;<span class="literal">()</span>;
    rqParmeter.add(<span class="keyword">new</span> <span class="type">BasicNameValuePair</span>(<span class="string">"input"</span>,gson.toJson(rqRobot)));
    <span class="keyword">try</span> {
        post.setEntity(<span class="keyword">new</span> <span class="type">UrlEncodedFormEntity</span>(rqParmeter, <span class="type">HTTP</span>.<span class="type">UTF_8</span>));

    } catch (<span class="type">UnsupportedEncodingException</span> e) {
        e.printStackTrace<span class="literal">()</span>;
    }

    <span class="type">Robot</span> rpRobot=null;
    <span class="type">Log</span>.e(<span class="string">"niinin"</span>,<span class="string">"----------------------------"</span>);

    <span class="keyword">try</span> {
        <span class="type">HttpResponse</span> httpResponse=client.execute(post);
        <span class="built_in">int</span> statusCode=  httpResponse.getStatusLine<span class="literal">()</span>.getStatusCode<span class="literal">()</span>;

        <span class="type">Log</span>.e(<span class="string">"dsdsd"</span>,statusCode+<span class="string">""</span>);
        <span class="keyword">if</span> (statusCode==<span class="number">200</span>){
            <span class="type">HttpEntity</span> httpEntity= httpResponse.getEntity<span class="literal">()</span>;
            <span class="type">Log</span>.e(<span class="string">"niinin"</span>,httpResponse.getEntity<span class="literal">()</span>.toString<span class="literal">()</span>);
          rpRobot=gson.fromJson(<span class="type">EntityUtils</span>.toString(httpEntity),<span class="type">Robot</span>.<span class="keyword">class</span>);
        }
    } catch (<span class="type">IOException</span> e) {
        e.printStackTrace<span class="literal">()</span>;
    }

    return rpRobot;
}
</code></pre><p> 执行client上传数据，接收到的就是返回值：<br>HttpResponse response = client.execute(post);</p>
<p>得到返回值：response.getEntity()</p>
<p>但是得到的返回值不是字符串，要先把他转为字符串：</p>
<p>使用EntityUtils的方法来转化为字符串</p>
<p>EntityUtils.toString(response.getEntity());</p>
<pre><code> <span class="comment">// setting request parameters</span>
    List&lt;NameValuePair&gt; requestParameters = <span class="keyword">new</span> ArrayList&lt;&gt;();
    <span class="comment">// send imageSize parameter to server for recognition</span>
    requestParameters.<span class="built_in">add</span>(<span class="keyword">new</span> BasicNameValuePair(<span class="string">"action"</span>, <span class="string">"findById"</span>));
    requestParameters.<span class="built_in">add</span>(<span class="keyword">new</span> BasicNameValuePair(<span class="string">"imageSize"</span>, <span class="string">"400"</span>));
    requestParameters.<span class="built_in">add</span>(<span class="keyword">new</span> BasicNameValuePair(<span class="string">"id"</span>, Integer
            .toString(spotId)));

    <span class="keyword">try</span> {
<span class="comment">//要将list转化为转化为Entity，可以调用UrlEncodedFormEntity方法转化</span>
        post.setEntity(<span class="keyword">new</span> UrlEncodedFormEntity(requestParameters,
                HTTP.UTF_8));
</code></pre><p><a href="http://zszdevelop.github.io/2015/05/27/2015-5-27/" target="_blank" rel="external">http://zszdevelop.github.io/2015/05/27/2015-5-27/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/06/08/2015-6-8/" data-id="cicznlcoq000nisb2padcwoy8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


    
      <article id="post-2015-6-5-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/05/2015-6-5-2/">java集合的使用</a>
    </h1>
  

        <div class="article-meta">
          <div class="article-date">
  <i class="fa fa-calendar"></i>
  <a href="/2015/06/05/2015-6-5-2/">
    <time datetime="2015-06-05T03:06:22.000Z" itemprop="datePublished">2015-06-05</time>
  </a>
</div>
          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java集合">Java集合</h1><p>java集合接口（接口不能直接实例化、要实例化他的子类）：</p>
<ul>
<li>Collection 接口</li>
<li>List接口</li>
<li>Set接口</li>
<li>Iterator接口</li>
<li>Map接口</li>
</ul>
<h2 id="接口之间的关系图">接口之间的关系图</h2><p><img src="http://cl.ly/image/1F3P3E42350q/IC$HBD%601%7BZ2A%60S3K]L@C05V.png" alt="接口之间关系"></p>
<h2 id="集合">集合</h2><ul>
<li>1.集合可以理解为一个动态的对象数组，不同的是集合的对象内容可以任意扩充</li>
<li>2.集合的特点：<br> 性能高，容易扩展和修改<h2 id="List接口">List接口</h2>List继承自Collection</li>
<li>1.List接口可以存放任意的数据，而且在List接口中内容是可以重复的</li>
<li>2.List接口常用子类</li>
<li><ul>
<li>Arraylist</li>
<li>Vector</li>
</ul>
</li>
</ul>
<p>Arraylist和Vector的实现差不多，他们之间的区别就是</p>
<ul>
<li>Arraylist：采用异步处理方式，性能高，属于非线程安全。</li>
<li>Vector：采用同步处理方式，性能低，属于线程安全。</li>
</ul>
<p>ArrayList的简单实例</p>
<pre><code><span class="keyword">import</span> java.util.ArrayList;
<span class="keyword">import</span> java.util.List;

<span class="keyword">public</span> class ListTest {

<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) {
    <span class="comment">// TODO Auto-generated method stub</span>

    <span class="comment">//List是一个接口，必须实例化其子类。</span>
    List&lt;<span class="keyword">String</span>&gt; list=<span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;();
    <span class="comment">//集合使用add添加</span>
    list.<span class="built_in">add</span>(<span class="string">"添加字符串"</span>);
    list.<span class="built_in">add</span>(<span class="string">"A"</span>);
    list.<span class="built_in">add</span>(<span class="string">"B"</span>);
    list.<span class="built_in">add</span>(<span class="string">"C"</span>);

    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;list.<span class="built_in">size</span>(); i++) {
        <span class="comment">//集合使用get方法来获取元素内容。</span>
        System.out.<span class="built_in">println</span>(list.<span class="built_in">get</span>(i));
    }
    <span class="comment">//remove删除操作</span>
    list.remove(<span class="number">0</span>);
    System.out.<span class="built_in">println</span>(<span class="string">"删除后的操作"</span>);
    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; list.<span class="built_in">size</span>(); i++) {
        System.out.<span class="built_in">println</span>(list.<span class="built_in">get</span>(i));
    }
    System.out.<span class="built_in">println</span>(<span class="string">"判断集合是否为空"</span>+list.isEmpty());
    <span class="comment">//indexOf返回值是元素的位置。</span>
    System.out.<span class="built_in">println</span>(<span class="string">"判断元素是否存在，例如C: "</span>+list.indexOf(<span class="string">"C"</span>));
}

}
</code></pre><h2 id="Set接口">Set接口</h2><ul>
<li>1.Set接口中不能加入重复元素，但是可以排序</li>
<li>2.常用子类：HashSet 和TreeSet </li>
</ul>
<p>HashSet：无順序性，查找速度快<br>（注意相同多个D，set只会读取一个）<br>TreeSet：有排序性(依字母)，由紅黑樹所建 </p>
<pre><code>import java.util.TreeSet;

public class SetTest {

public static void main(String[] args) {
    // TODO Auto-generated method stub

//        <span class="operator"><span class="keyword">Set</span>&lt;<span class="keyword">String</span>&gt; <span class="keyword">set</span>=new HashSet&lt;<span class="keyword">String</span>&gt;();</span>
    <span class="operator"><span class="keyword">Set</span>&lt;<span class="keyword">String</span>&gt; <span class="keyword">set</span>=new TreeSet&lt;<span class="keyword">String</span>&gt;();</span>
    <span class="operator"><span class="keyword">set</span>.<span class="keyword">add</span>(<span class="string">"2"</span>);</span>
    <span class="operator"><span class="keyword">set</span>.<span class="keyword">add</span>(<span class="string">"4"</span>);</span>
    <span class="operator"><span class="keyword">set</span>.<span class="keyword">add</span>(<span class="string">"1"</span>);</span>
    <span class="operator"><span class="keyword">set</span>.<span class="keyword">add</span>(<span class="string">"31"</span>);</span>
    <span class="operator"><span class="keyword">set</span>.<span class="keyword">add</span>(<span class="string">"a"</span>);</span>
    <span class="operator"><span class="keyword">set</span>.<span class="keyword">add</span>(<span class="string">"D"</span>);</span>
    <span class="operator"><span class="keyword">set</span>.<span class="keyword">add</span>(<span class="string">"D"</span>);</span>

    System.out.println(<span class="operator"><span class="keyword">set</span>);</span>
}

}
</code></pre><h2 id="Iterator接口">Iterator接口</h2><p>1.集合输出的标准操作：标准做法，使用Iterator接口<br>2.操作原理：Iterator是专门的迭代输出接口，迭代输出就是将元素一个个进行判断，判断其是否有内容，如果有内容则把内容取出。</p>
<p>Iterator的实例化比较特别：是通过集合来获得他的一个对象，来实例化。</p>
<p>hasNext()：判断集合中元素是否遍历完毕，如果没有，就返回true<br>next() ：返回下一个元素 </p>
<pre><code>package com.zsz.develop;

<span class="keyword">import</span> java.util.<span class="type">ArrayList</span>;
<span class="keyword">import</span> java.util.<span class="type">Iterator</span>;
<span class="keyword">import</span> java.util.<span class="type">List</span>;

public class <span class="type">IteratorTest</span> {

public <span class="keyword">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args) {
    // <span class="type">TODO</span> <span class="type">Auto</span>-generated <span class="keyword">method</span> stub

    <span class="type">List</span>&lt;<span class="type">Integer</span>&gt; list=new <span class="type">ArrayList</span>&lt;<span class="type">Integer</span>&gt;();
    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {
        list.add(i);

    }
    //使用<span class="type">Iterator</span>标准输出格式来输出
    <span class="type">Iterator</span>&lt;<span class="type">Integer</span>&gt; <span class="keyword">iterator</span>=list.<span class="keyword">iterator</span>();
    <span class="keyword">while</span> (<span class="keyword">iterator</span>.hasNext()) {
        <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="keyword">iterator</span>.next());
    }
}

}
</code></pre><h2 id="Map接口">Map接口</h2><p>1.保存形式：是以Key—value对的方式来保存<br>2.常用子类</p>
<ul>
<li>HashMap：无序存放，KEY不允许重复、</li>
<li>Hashtable：无序存放，KEY不允许重复、</li>
</ul>
<p>在list，set中添加数据都是使用add，而map是使用put添加数据。<br>通过map.get（）可以得到Key中的Value。</p>
<p>要得到所以的键：Map.keySet() 返回类型是set&lt;&gt;;<br>要得到所以的值：Map.Value 返回类型是Collection&lt;&gt;;</p>
<p>map实例</p>
<pre><code>package com.zsz.develop;

<span class="keyword">import</span> java.util.<span class="type">Collection</span>;
<span class="keyword">import</span> java.util.<span class="type">HashMap</span>;
<span class="keyword">import</span> java.util.<span class="type">Iterator</span>;
<span class="keyword">import</span> java.util.<span class="type">Map</span>;
<span class="keyword">import</span> java.util.<span class="type">Set</span>;

public class <span class="type">MapTest</span> {

public <span class="keyword">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args) {
    // <span class="type">TODO</span> <span class="type">Auto</span>-generated <span class="keyword">method</span> stub

    //键值对的形式来存储数据
    <span class="type">Map</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; map=new <span class="type">HashMap</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt;();
    map.put(<span class="string">"key1"</span>, <span class="string">"first"</span>);
    map.put(<span class="string">"key2"</span>, <span class="string">"first2"</span>);
    map.put(<span class="string">"key3"</span>, <span class="string">"first3"</span>);
    map.put(<span class="string">"key4"</span>, <span class="string">"first4"</span>);

    //得到所以的键
    <span class="type">Set</span>&lt;<span class="type">String</span>&gt; <span class="type">set</span>=map.keySet();
    <span class="type">Iterator</span>&lt;<span class="type">String</span>&gt; <span class="keyword">iterator</span>=<span class="type">set</span>.<span class="keyword">iterator</span>();
    <span class="keyword">while</span> (<span class="keyword">iterator</span>.hasNext()) {
        <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="keyword">iterator</span>.next());
    }

    <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"上面为全部键，下面为全部值"</span>);
    //得到所有的值
    <span class="type">Collection</span>&lt;<span class="type">String</span>&gt; collection=map.values();
    <span class="type">Iterator</span>&lt;<span class="type">String</span>&gt; i=collection.<span class="keyword">iterator</span>();
    <span class="keyword">while</span> (i.hasNext()) {
        <span class="type">System</span>.<span class="keyword">out</span>.println(i.next());

    }

    //判断是否存在键
    <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"是否存在键： "</span>+map.containsKey(<span class="string">"key1"</span>));
    //判断是否存在值
    <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"是否存在值： "</span>+map.containsKey(<span class="string">"first1"</span>));

}


}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/06/05/2015-6-5-2/" data-id="cicznlcov000pisb286jtxwf2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


    
      <article id="post-2015-6-5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/04/2015-6-5/">SharedPrefenences的使用</a>
    </h1>
  

        <div class="article-meta">
          <div class="article-date">
  <i class="fa fa-calendar"></i>
  <a href="/2015/06/04/2015-6-5/">
    <time datetime="2015-06-04T13:40:35.000Z" itemprop="datePublished">2015-06-04</time>
  </a>
</div>
          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="SharedPrefenences是什么">SharedPrefenences是什么</h1><p>SharedPrefenences是一种轻型的数据存储方式，他的本质是基于XML文件存储<strong>Ket-Value键值对数据</strong>，通常用来存储一些简单的<strong>配置信息</strong>。</p>
<p>存储位置在/data/data/&lt;包名&gt;/shared_prefs目录下。</p>
<p>SharedPrefenences对象本身只能获取数据而<strong>不支持存储和修改，存储修改要通过Editor对象实现。</strong></p>
<h1 id="SharedPrefenences的优势">SharedPrefenences的优势</h1><p>SharedPrefenences与SQLite数据库相比，免去了创建数据库，创建表，写SQL语句等操作，更加易用。</p>
<p>支持的类型数据</p>
<ul>
<li>boolean</li>
<li>int</li>
<li>float</li>
<li>long</li>
<li>String</li>
</ul>
<p>但是无法进行条件查询。</p>
<h1 id="SharedPrefenences的代码实现">SharedPrefenences的代码实现</h1><p>Activity：</p>
<pre><code><span class="keyword">package</span> com.zsz.develop.sharedpreferencestest;

<span class="keyword">import</span> android.content.SharedPreferences;
<span class="keyword">import</span> android.support.v7.app.ActionBarActivity;
<span class="keyword">import</span> android.os.Bundle;
<span class="keyword">import</span> android.view.Menu;
<span class="keyword">import</span> android.view.MenuItem;
<span class="keyword">import</span> android.view.View;
<span class="keyword">import</span> android.widget.EditText;
<span class="keyword">import</span> android.widget.Toast;


<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">ActionBarActivity</span> </span>{

<span class="keyword">private</span> EditText etData;
<span class="keyword">private</span>  SharedPreferences sharedPreferences;
<span class="annotation">@Override</span>
<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{
    <span class="keyword">super</span>.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    etData= (EditText) findViewById(R.id.etData);
    sharedPreferences=getSharedPreferences(<span class="string">"sharedPrefXML"</span>,MODE_PRIVATE);
    <span class="comment">//要编辑修改sharedPreferences就要使用Editor来修改</span>
   <span class="keyword">final</span> SharedPreferences.Editor editor= sharedPreferences.edit();

    <span class="comment">//读取SharedPreferences数据</span>
    findViewById(R.id.btnRead).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() {
        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>{

            <span class="comment">//得到sharedPreferences的值,传进去第一个参数是键，第二个是如果为空返回的值。</span>
          String value=  sharedPreferences.getString(<span class="string">"key-name"</span>,<span class="string">"当前数值不存在"</span>);
            Toast.makeText(getApplicationContext(),value,Toast.LENGTH_SHORT).show();
        }
    });

    <span class="comment">//写入SharedPreferences数据</span>
    findViewById(R.id.btnWrite).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() {
        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>{

            <span class="comment">//要修改存储什么类型数据就put什么类型,这里传进去的是Key-Value</span>
            editor.putString(<span class="string">"key-name"</span>,etData.getText().toString().trim());
            <span class="comment">//commit提交数据,commit返回值为boolean。进行判断</span>
          <span class="keyword">if</span> (editor.commit()) {
              Toast.makeText(getApplicationContext(), <span class="string">"写入成功"</span>, Toast.LENGTH_SHORT).show();
          }
        }
    });



}



}
</code></pre><p>layout档：</p>
<pre><code>&lt;LinearLayout xmlns:<span class="variable">android=</span><span class="string">"http://schemas.android.com/apk/res/android"</span>
xmlns:<span class="variable">tools=</span><span class="string">"http://schemas.android.com/tools"</span> android:<span class="variable">layout_width=</span><span class="string">"match_parent"</span>
android:<span class="variable">layout_height=</span><span class="string">"match_parent"</span>
android:<span class="variable">orientation=</span><span class="string">"vertical"</span>&gt;
&lt;EditText
   android:<span class="variable">layout_width=</span><span class="string">"fill_parent"</span>
   android:<span class="variable">layout_height=</span><span class="string">"wrap_content"</span>
   android:<span class="variable">id=</span><span class="string">"@+id/etData"</span>
   /&gt;
&lt;Button
    android:<span class="variable">layout_width=</span><span class="string">"fill_parent"</span>
    android:<span class="variable">layout_height=</span><span class="string">"wrap_content"</span>
    android:<span class="variable">id=</span><span class="string">"@+id/btnRead"</span>
    android:<span class="variable">text=</span><span class="string">"读取数据"</span>
    /&gt;

&lt;Button
    android:<span class="variable">layout_width=</span><span class="string">"fill_parent"</span>
    android:<span class="variable">layout_height=</span><span class="string">"wrap_content"</span>
    android:<span class="variable">id=</span><span class="string">"@+id/btnWrite"</span>
    android:<span class="variable">text=</span><span class="string">"写入数据"</span>
    /&gt;
&lt;/LinearLayout&gt;
</code></pre><p>SharedPrefenences非常方便的使用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/06/04/2015-6-5/" data-id="cicznlcos000oisb2eb31hz1y" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


    
      <article id="post-2015-6-4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/04/2015-6-4/">清除用户数据</a>
    </h1>
  

        <div class="article-meta">
          <div class="article-date">
  <i class="fa fa-calendar"></i>
  <a href="/2015/06/04/2015-6-4/">
    <time datetime="2015-06-04T08:03:24.000Z" itemprop="datePublished">2015-06-04</time>
  </a>
</div>
          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="清除用户数据">清除用户数据</h1><p>非常实用的清空数据函数。</p>
<p>主要通过deleteFilesByDirectory（）函数删除文件，来达到清楚数据的功能。</p>
<p>功能有清除内/外缓存，清除数据库，清除sharedPreference，清除files和清除自定义目录</p>
<pre><code>package com.fsd.zsz.manplan.main;

/<span class="keyword">*</span><span class="keyword">*</span>
 <span class="keyword">*</span> Created by shengzhong on 2015/6/3.
 <span class="keyword">*</span>/


import java.io.File;
import android.content.Context;
import android.os.Environment;
/<span class="keyword">*</span><span class="keyword">*</span> <span class="keyword">*</span> 本应用数据清除管理器 <span class="keyword">*</span>/
public class DataCleanManager {
    /<span class="keyword">*</span><span class="keyword">*</span> <span class="keyword">*</span> 清除本应用内部缓存(/data/data/com.xxx.xxx/cache) <span class="keyword">*</span> <span class="keyword">*</span> <span class="comment">@param context */</span>
    public static void cleanInternalCache(Context context) {
        deleteFilesByDirectory(context.getCacheDir());
    }
    /<span class="keyword">*</span><span class="keyword">*</span> <span class="keyword">*</span> 清除本应用所有数据库(/data/data/com.xxx.xxx/databases) <span class="keyword">*</span> <span class="keyword">*</span> <span class="comment">@param context */</span>
    public static void cleanDatabases(Context context) {
        deleteFilesByDirectory(new File(<span class="string">"/data/data/"</span>
                + context.getPackageName() + <span class="string">"/databases"</span>));
    }
    /<span class="keyword">*</span><span class="keyword">*</span>
     <span class="keyword">*</span> <span class="keyword">*</span> 清除本应用SharedPreference(/data/data/com.xxx.xxx/shared_prefs) <span class="keyword">*</span> <span class="keyword">*</span> <span class="comment">@param</span>
     <span class="keyword">*</span> context
     <span class="keyword">*</span>/
    public static void cleanSharedPreference(Context context) {
        deleteFilesByDirectory(new File(<span class="string">"/data/data/"</span>
                + context.getPackageName() + <span class="string">"/shared_prefs"</span>));
    }
    /<span class="keyword">*</span><span class="keyword">*</span> <span class="keyword">*</span> 按名字清除本应用数据库 <span class="keyword">*</span> <span class="keyword">*</span> <span class="comment">@param context * @param dbName */</span>
    public static void cleanDatabaseByName(Context context, String dbName) {
        context.deleteDatabase(dbName);
    }
    /<span class="keyword">*</span><span class="keyword">*</span> <span class="keyword">*</span> 清除/data/data/com.xxx.xxx/files下的内容 <span class="keyword">*</span> <span class="keyword">*</span> <span class="comment">@param context */</span>
    public static void cleanFiles(Context context) {
        deleteFilesByDirectory(context.getFilesDir());
    }
    /<span class="keyword">*</span><span class="keyword">*</span>
     <span class="keyword">*</span> <span class="keyword">*</span> 清除外部cache下的内容(/mnt/sdcard/android/data/com.xxx.xxx/cache) <span class="keyword">*</span> <span class="keyword">*</span> <span class="comment">@param</span>
     <span class="keyword">*</span> context
     <span class="keyword">*</span>/
    public static void cleanExternalCache(Context context) {
        if (Environment.getExternalStorageState().equals(
                Environment.MEDIA_MOUNTED)) {
            deleteFilesByDirectory(context.getExternalCacheDir());
        }
    }
    /<span class="keyword">*</span><span class="keyword">*</span> <span class="keyword">*</span> 清除自定义路径下的文件，使用需小心，请不要误删。而且只支持目录下的文件删除 <span class="keyword">*</span> <span class="keyword">*</span> <span class="comment">@param filePath */</span>
    public static void cleanCustomCache(String filePath) {
        deleteFilesByDirectory(new File(filePath));
    }
    /<span class="keyword">*</span><span class="keyword">*</span> <span class="keyword">*</span> 清除本应用所有的数据 <span class="keyword">*</span> <span class="keyword">*</span> <span class="comment">@param context * @param filepath */</span>
    public static void cleanApplicationData(Context context, String... filepath) {
        cleanInternalCache(context);
        cleanExternalCache(context);
        cleanDatabases(context);
        cleanSharedPreference(context);
        cleanFiles(context);
        for (String filePath : filepath) {
            cleanCustomCache(filePath);
        }
    }
    /<span class="keyword">*</span><span class="keyword">*</span> <span class="keyword">*</span> 删除方法 这里只会删除某个文件夹下的文件，如果传入的directory是个文件，将不做处理 <span class="keyword">*</span> <span class="keyword">*</span> <span class="comment">@param directory */</span>
    private static void deleteFilesByDirectory(File directory) {
        if (directory != null &amp;&amp; directory.exists() &amp;&amp; directory.isDirectory()) {
            for (File item : directory.listFiles()) {
                item.delete();
            }
        }
    }
}
</code></pre><p>出处：<a href="http://blog.csdn.net/berber78/article/details/38587567" target="_blank" rel="external">http://blog.csdn.net/berber78/article/details/38587567</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/06/04/2015-6-4/" data-id="cicznlcox000qisb24b8er19n" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


    
      <article id="post-2015-5-31" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/31/2015-5-31/">Android设置日期与时间</a>
    </h1>
  

        <div class="article-meta">
          <div class="article-date">
  <i class="fa fa-calendar"></i>
  <a href="/2015/05/31/2015-5-31/">
    <time datetime="2015-05-31T11:51:39.000Z" itemprop="datePublished">2015-05-31</time>
  </a>
</div>
          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Android设置日期与时间">Android设置日期与时间</h1><p>取得设置系统时间是Android非常实用的一个功能</p>
<h2 id="取得系统时间">取得系统时间</h2><p>实例化Calendar时，他已经默认的设置了系统时间。<br>setTimeInMillis（）这个方法，会根据你传入的毫秒数对日历对象中的变量进行相应设置。System.currentTimeMillis()可以得到系统到距离1970年1月1日0时的毫秒数</p>
<pre><code>      <span class="comment">//Calendar定义日历对象</span>
<span class="keyword">private</span> Calendar calendar;
    <span class="comment">//实例化日历对象</span>
    calendar=Calendar.getInstance();
    <span class="comment">//设置系统时间</span>
    calendar.setTimeInMillis(System.currentTimeMillis());
    <span class="comment">//得到系统时间</span>
   <span class="keyword">final</span> Date time=calendar.getTime();
    <span class="comment">//得到时和分</span>
   <span class="keyword">final</span> <span class="built_in">int</span> <span class="built_in">hour</span>= calendar.<span class="built_in">get</span>(Calendar.HOUR_OF_DAY);
    <span class="keyword">final</span> <span class="built_in">int</span> <span class="built_in">minute</span>=calendar.<span class="built_in">get</span>(Calendar.MINUTE);
</code></pre><h2 id="时间选择器">时间选择器</h2><p>时间选择器：<br>TimePickerDialog(Contextcontext,TimePickerDialog.OnTimeSetListenercallBack, int hourOfDay, int minute, boolean is24HourView)</p>
<ul>
<li><p>其中TimePickerDialog.OnTimeSetListenercallBack是用户选择好时间后，通知应用的回调函数。监听用户更改时间参数，调用的方法。</p>
</li>
<li><p>is24HourView选择是否为24小时制</p>
</li>
<li></li>
</ul>
<pre><code>tvTime= (TextView) findViewById(R.id.tvTime);
   tvTime.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() {
       <span class="annotation">@Override</span>
       <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>{
           <span class="keyword">new</span> TimePickerDialog(MainActivity.<span class="keyword">this</span>,<span class="keyword">new</span> TimePickerDialog.OnTimeSetListener() {
               <span class="annotation">@Override</span>
               <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onTimeSet</span><span class="params">(TimePicker timePicker, <span class="keyword">int</span> i, <span class="keyword">int</span> i2)</span> </span>{
                   tvTime.setText(<span class="string">"shi"</span>+i+<span class="string">"fen"</span>+i2);
               }
           },<span class="number">10</span>,<span class="number">20</span>,<span class="keyword">true</span>).show();
       }
   });
</code></pre><h2 id="日期选择器">日期选择器</h2><p>同理时间选择器</p>
<pre><code>tvDate= (TextView) findViewById(R.id.tvDate);
   tvDate.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() {
       <span class="annotation">@Override</span>
       <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>{

           <span class="keyword">new</span> DatePickerDialog(MainActivity.<span class="keyword">this</span>, <span class="keyword">new</span> DatePickerDialog.OnDateSetListener() {
               <span class="annotation">@Override</span>
               <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onDateSet</span><span class="params">(DatePicker view, <span class="keyword">int</span> year, <span class="keyword">int</span> monthOfYear, <span class="keyword">int</span> dayOfMonth)</span> </span>{

                   tvDate.setText(String.format(<span class="string">"%d:%d:%d"</span>,year,monthOfYear,dayOfMonth));
               }

           },<span class="number">2015</span>,<span class="number">6</span>,<span class="number">2</span>).show();
       }
   });
</code></pre><p>Layout档</p>
<pre><code>   &lt;TextView
    android:<span class="variable">layout_width=</span><span class="string">"wrap_content"</span>
    android:<span class="variable">layout_height=</span><span class="string">"wrap_content"</span>
    android:<span class="variable">text=</span><span class="string">"0000:00:00"</span>
    android:<span class="variable">id=</span><span class="string">"@+id/tvDate"</span>
    /&gt;

&lt;TextView
    android:<span class="variable">layout_width=</span><span class="string">"wrap_content"</span>
    android:<span class="variable">layout_height=</span><span class="string">"wrap_content"</span>
    android:<span class="variable">text=</span><span class="string">"00:00:00"</span>
    android:<span class="variable">id=</span><span class="string">"@+id/tvTime"</span>
    /&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/05/31/2015-5-31/" data-id="cicznlcp1000risb2mm1qppxk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


    
      <article id="post-2015-5-27" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/27/2015-5-27/">Android 非同步任務 - AsyncTask</a>
    </h1>
  

        <div class="article-meta">
          <div class="article-date">
  <i class="fa fa-calendar"></i>
  <a href="/2015/05/27/2015-5-27/">
    <time datetime="2015-05-27T13:14:38.000Z" itemprop="datePublished">2015-05-27</time>
  </a>
</div>
          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Android_非同步任務_-_AsyncTask">Android 非同步任務 - AsyncTask</h1><h2 id="Android为什么要使用多线程">Android为什么要使用多线程</h2><ul>
<li>提高用户体验或者避免ANR（如果在主线程（UI线程）操作一些耗时的操作容易造成卡顿<br>android 规定主线程中不可以做http 连接操作。）</li>
<li>异步</li>
<li>多任务</li>
</ul>
<p>当主线程（UI线程）操作到一些复杂的IO操作（文件操作，网络操作，数据库操作），复杂运算等耗时操作，容易造成卡顿。</p>
<p>应用程序弹出“无响应”的对话框（ANR），那是因为在Android主线程中进行了超时的操作，过多的阻塞了主线程就会导致应用出现ANR的Waring。(android 规定主线程中不可以做http 连接操作)</p>
<h2 id="AsyncTask是什么">AsyncTask是什么</h2><p>  AsyncTask,是android提供的輕量級的非同步類,可以直接繼承AsyncTask,在類中實現非同步操作,並提供介面反饋當前非同步執行的程度(可以通過介面實現UI進度更新),最後反饋執行的結果給UI主線程.</p>
<h2 id="为什么使用AsyncTask">为什么使用AsyncTask</h2><ul>
<li>AsyncTask能实现多线程，避免ANR</li>
<li>简单快捷易操作</li>
<li>过程可控</li>
</ul>
<h2 id="AsyncTask怎么使用">AsyncTask怎么使用</h2><p>AsyncTask定义了三种泛型类型 Params，Progress和Result。<br>Params 启动任务执行的输入参数，比如HTTP请求的URL。<br>Progress 后台任务执行的百分比。<br>Result 后台执行任务最终返回的结果，比如String。 </p>
<pre><code>`private class <span class="type">TestAsyncTask</span> extends <span class="type">AsyncTask</span>&lt;<span class="type">String</span>, <span class="type">Void</span>, <span class="type">Boolean</span>&gt; 

{

 @<span class="type">Override</span>
  protected <span class="type">void</span> onPreExecute() 
  {
    //最先执行的就是这个。一遍添加进度条
 }

  @<span class="type">Override</span>
  protected <span class="type">Boolean</span> doInBackground(<span class="type">String</span>... params)
  {
    //这个是在后台执行的东西，就是说，它自动另外开了个线程运行，不影响你现在做的东西。
    //复杂的<span class="type">IO</span>操作（文件操作，网络操作，数据库操作），复杂运算等耗时操作
 }


@<span class="type">Override</span>
  protected <span class="type">void</span> onPostExecute(<span class="type">Boolean</span> <span class="literal">result</span>)
  {
    <span class="keyword">if</span> (<span class="literal">result</span>)
    {
      //后台执行的完毕后，它会用<span class="type">Result</span>通知这里，就是执行这里了。
  }
    <span class="keyword">else</span>
    {
      //所以最好判断一下<span class="literal">result</span>，写个<span class="keyword">else</span>，判断后台执行的东西是不是出问题了。
  }
  }
}`
</code></pre><p><a href="http://yuchen.blog.51cto.com/2739238/593019" title="如何在Android中用好多线程" target="_blank" rel="external">http://yuchen.blog.51cto.com/2739238/593019</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/05/27/2015-5-27/" data-id="cicznlcp2000sisb29k63kjnf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


    
      <article id="post-2015-5-24" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/24/2015-5-24/">Dao模式</a>
    </h1>
  

        <div class="article-meta">
          <div class="article-date">
  <i class="fa fa-calendar"></i>
  <a href="/2015/05/24/2015-5-24/">
    <time datetime="2015-05-24T14:08:39.000Z" itemprop="datePublished">2015-05-24</time>
  </a>
</div>
          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="DAO模式">DAO模式</h2><p>信息系统的架构分为：</p>
<p>客户层———-显示层———-业务层————-数据层————-数据库</p>
<ul>
<li>1.客户层：客户层就是客户端，简单的来说就是浏览器。</li>
<li>2.显示层：JSP/Servlet，用于给浏览器显示。</li>
<li>3.业务层：对于数据层的原子操作进行整合。（Dao）</li>
<li>4.数据层：对于数据库进行的原子操作，增加、删除等；（DaoImpl）</li>
</ul>
<p>说直白点就是定义了一个接口（Dao），让（DaoImpl）去实现这个接口。</p>
<h2 id="Dao层包含的类">Dao层包含的类</h2><p>DAO层一般有接口和该接口的实现类！</p>
<ul>
<li>接口用于规范实现类！</li>
<li>实现类一般用于用于操作数据库！ 一般操作修改，添加，删除数据库操作的步骤很相似，就写了一个公共类DAO类 ，修改，添加，删除数据库操作时 直接调用公共类DAO类！</li>
</ul>
<h2 id="为什么使用Dao">为什么使用Dao</h2><p>Dao是接口，他的优势就是接口的优势。</p>
<p>接口作为系统与外界交互的窗口，接口体现是一种规范。</p>
<p>对于接口的实现者而言，接口规定了实现者必须向外提供哪些服务(以方法的形式来提供)；</p>
<p>对于接口调用者而言，接口规定了调用者可以调用哪些服务，以及如何调用这些服务（就是如何来调用方法的）。</p>
<p>当一个程序中使用接口时，接口是多个模块之间的耦合标准；</p>
<p>当多个应用程序之间使用时，接口时多个程序之间的通信标准。</p>
<p>从某种程度来说，接口类型整个系统中的“总纲”，它制定了系统之间各个模块应该遵循的标准，因此一个系统中的接口不应该经常改变。一旦接口改变，对整个系统<br>甚至其他系统的影响将是辐射式的，导致系统中大部分类需要重写。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/05/24/2015-5-24/" data-id="cicznlcp4000tisb2n6c6qjrf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


    
      <article id="post-2015-5-17" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/17/2015-5-17/">jsp两种设计模型 </a>
    </h1>
  

        <div class="article-meta">
          <div class="article-date">
  <i class="fa fa-calendar"></i>
  <a href="/2015/05/17/2015-5-17/">
    <time datetime="2015-05-17T11:14:59.000Z" itemprop="datePublished">2015-05-17</time>
  </a>
</div>
          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="jsp两种设计模型">jsp两种设计模型</h1><ul>
<li>jsp+javaBean</li>
<li>jsp+javaBean+Servlet</li>
</ul>
<p>其实还有第三种，纯粹用jsp来编写。由jsp来处理业务逻辑，显示页面，控制流程。由于这种代码繁琐，可重复性差、不易于维护所以很快被市场抛弃了</p>
<h2 id="jsp+javaBean">jsp+javaBean</h2><p>页面显示和业务逻辑处理分开，JSP实现页面显示，JavaBean对象用来保存数据和实现商业逻辑</p>
<p> 工作原理是：当浏览器发出请求时，jsp接受请求并访问javabean。若需要访问数据库后台服务器，则通过javaBean连接数据库或后台服务器，执行相应的处理。javaBean将处理的结果数据交给jsp。jsp提取结果并重新组织后，动态生成HRML页面，返回给浏览器。用户从浏览器显示的页面中得到交互的结果</p>
<h2 id="jsp+javaBean+Servlet">jsp+javaBean+Servlet</h2><p>把流程控制代码和部分的逻辑处理代码提取到servlet中去。</p>
<p>mvc架构：model层  +view层 controller层</p>
<ul>
<li>model：实现业务逻辑，包括了web应用程序功能的核心，负责存储与<br>应用程序相关的数据</li>
<li>view：用于用户的页面显示，他可以访问model层数据，但不能更改这些数据</li>
<li>Controller：主要负责model和view的控制关系，负责处理http的请求等</li>
</ul>
<p>并不是说mvc架构就更好。<br>根据实际来选择：</p>
<ul>
<li>当事务逻辑比较负责、分支较多或需要涉及很多JavaBean组件时，由于JSP和JavaBean+Servlet模型比JSP和JavaBean模型有更清晰的页面表现、更明确的开发模块的划分，所以使用JSP和JavaBean+Servlet模型比较适合</li>
<li>对于简单的交互处理，利用JSP和JavaBean模型，JSP主要是使用HTML工具开发，然后再插入少量的Java代码就可以实现动态交互。在这种情况下，使用JSP和JavaBean模型更加方便快捷</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/05/17/2015-5-17/" data-id="cicznlcp5000uisb2qi82ajpe" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


    
      <article id="post-2015-5-16" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/16/2015-5-16/">jsp九大内置对象</a>
    </h1>
  

        <div class="article-meta">
          <div class="article-date">
  <i class="fa fa-calendar"></i>
  <a href="/2015/05/16/2015-5-16/">
    <time datetime="2015-05-16T13:30:35.000Z" itemprop="datePublished">2015-05-16</time>
  </a>
</div>
          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="jsp九大内置对象">jsp九大内置对象</h1><ul>
<li>out 输出对象</li>
<li>request 请求对象</li>
<li>reponse 响应对象</li>
<li>session 会话层对象</li>
<li>application 应用层对象</li>
<li>config 配置对象</li>
<li>page 页面对象 </li>
<li>pageContext  页面上下文对象</li>
<li>Exception 异常对象</li>
</ul>
<h2 id="为什么要有内置对象">为什么要有内置对象</h2><p>因为这九大对象在jsp中使用太平繁，为了简化操作就事先内置在jsp中。程序员们就可以不用每次都去实例化操作。</p>
<p>（程序编写的绝大部分原因都是为了提高效率）</p>
<h2 id="out_（page）">out （page）</h2><p>out最常用的对象之一，<strong>向客户端输出各种数据对象。</strong></p>
<h2 id="request_（request）">request （request）</h2><p>request 是客户端向服务器发出的请求。<br><strong>封装了来自客户端的各种浏览信息</strong></p>
<p>通过getParameter、getParameterNames和getParameterValues方法来获取请求对象中所包含的参数的值。</p>
<p>也可以设置其属性值，setAttribute与getAttribute方法这两个方法先设置后取得。所以他们一般都是同时出现</p>
<p>request的作用域只有在请求时，当请求结束时，得到响应后就销毁</p>
<h2 id="response_（page）">response （page）</h2><p>response代表对客户端的响应。但一般比较少用，使用out直接输出</p>
<p><strong>封装了服务器的各种响应信息</strong></p>
<h2 id="session（session）">session（session）</h2><p><strong>session是保存了会话信息，也就是说他可以在同一用户之前共享数据</strong></p>
<p>session代表服务器与客户端所建立的会话。<br>一个完整的会话是：从客户端连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。</p>
<p>根据这个特性，session可以实现在线购物，密码安全等保存客户端状态信息操作</p>
<h2 id="application（application）">application（application）</h2><p><strong>表示了上下文信息，他可以在不同的用户信息共享信息</strong></p>
<p>application负责提供应用程序在服务器中运行时的一些全局信息。根据这个特性，他能实现浏览计数器</p>
<h2 id="config（page）">config（page）</h2><p><strong>封装了应用程序的配置信息</strong></p>
<h2 id="page（page）">page（page）</h2><p><strong>指向了jsp当前程序本身</strong></p>
<h2 id="pageContext（page）">pageContext（page）</h2><p><strong>提供了对jsp所有对象的访问</strong></p>
<h2 id="Exception（page）">Exception（page）</h2><p><strong>封装了程序执行中的异常或错误信息</strong></p>
<p>括号中的为作用域<br>剩下的以后用到的时候再谈。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/05/16/2015-5-16/" data-id="cicznlcp7000visb2mfrax5bj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


    
      <nav id="page-nav">
        <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
      </nav>
    </section>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 zszdevelop<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="http://github.com/ppoffice">PPOffice</a>
    </div>
  </div>
</footer>
    


<script src="//ajax.useso.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>