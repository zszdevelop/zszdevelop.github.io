<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>zszBlog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="this zszdeveloper blog��welcome��">
<meta property="og:type" content="website">
<meta property="og:title" content="zszBlog">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="zszBlog">
<meta property="og:description" content="this zszdeveloper blog��welcome��">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="zszBlog">
<meta name="twitter:description" content="this zszdeveloper blog��welcome��">
  
  
  <link href='//fonts.useso.com/css?family=Open+Sans:400italic,400,600' rel='stylesheet' type='text/css'>
  <link href="//fonts.useso.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css" type="text/css">
  

  
</head>
<body>
  <div id="container">
    <header id="header">
  <div id="header-main" class="header-inner">
    <div class="outer">
      <a href="/" id="logo"><i class="logo"></i><span class="site-title">zszBlog</span></a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/.">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/categories">Categories</a>
        
          <a class="main-nav-link" href="/tags">Tags</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        <div class="profile" id="profile-nav">
          <a id="profile-anchor" href="javascript:;"><img class="avatar" src="http://cl.ly/image/382p262u1E3o/%60IF)_M7]QGJMAK096_$F$$6.png"><i class="fa fa-caret-down"></i></a>
        </div>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"> </button><input type="hidden" name="q" value="site:http://yoursite.com"></form>
      </div>
    </div>
  </div>
  <div id="main-nav-mobile" class="header-sub header-inner">
    <table class="menu outer">
      <tr>
      
        <td><a class="main-nav-link" href="/.">Home</a></td>
      
        <td><a class="main-nav-link" href="/archives">Archives</a></td>
      
        <td><a class="main-nav-link" href="/categories">Categories</a></td>
      
        <td><a class="main-nav-link" href="/tags">Tags</a></td>
      
        <td><a class="main-nav-link" href="/about">About</a></td>
      
      <td>
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="hidden" name="q" value="site:http://yoursite.com"></form>
      </td>
      </tr>
    </table>
  </div>
</header>
    <div class="outer">
      <aside id="profile">
  <div class="inner profile-inner">
  	<div class="base-info profile-block">
		  <img id="avatar" src="http://cl.ly/image/382p262u1E3o/%60IF)_M7]QGJMAK096_$F$$6.png">
      <h2 id="name">zszdevelop</h2>
      <h3 id="title">Java&amp;Android Developer</h3>
      <span id="location"><i class="fa fa-map-marker"></i>XiaMen, China</span>
      <a id="follow" href="undefined">FOLLOW</a>
  	</div>
    <div class="article-info profile-block">
      <div class="article-info-block">
        56
        <span>posts</span>
      </div>
      <div class="article-info-block">
        0
        <span>tag</span>
      </div>
    </div>
    
    <div class="contact-info profile-block">
      <table class="contact-list">
        <tr>
        
          <td><a href="https://github.com/zszdevelop" target="_blank" title="github"><i class="fa fa-github"></i></a></td>
        
          <td><a href="/#" target="_blank" title="twitter"><i class="fa fa-twitter"></i></a></td>
        
          <td><a href="https://www.facebook.com/profile.php?id=100007317255366" target="_blank" title="facebook"><i class="fa fa-facebook"></i></a></td>
        
        </tr>
      </table>
    </div>
    
  </div>
</aside>
      <section id="main">
      <article id="post-2015-7-15" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/15/2015-7-15/">Android通过httpClient获取网络请求，响应状态码含义，Http请求时要添加权限</a>
    </h1>
  

        <div class="article-meta">
          <div class="article-date">
  <i class="fa fa-calendar"></i>
  <a href="/2015/07/15/2015-7-15/">
    <time datetime="2015-07-15T00:50:03.000Z" itemprop="datePublished">2015-07-15</time>
  </a>
</div>
          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Android通过httpClient获取网络请求">Android通过httpClient获取网络请求</h1><p>在HttpClient模块中用到了两个重要的类：HttpGet和HttpPost。这两个类分别用来提交HTTP GET和HTTP POST请求。</p>
<p>无论是使用HttpGet，还是使用HttpPost，都必须通过如下3步来访问HTTP资源。</p>
<ul>
<li>1.创建HttpGet或HttpPost对象，将要请求的URL通过构造方法传入HttpGet或HttpPost对象。</li>
<li>2.使用DefaultHttpClient类的execute方法发送HTTP GET或HTTP POST请求，并返回HttpResponse对象。</li>
<li>3.通过HttpResponse接口的getEntity方法返回响应信息，并进行相应的处理。（判断请求响应状态码，状态码为200表示服务端成功响应了客户端的请求。</li>
</ul>
<h2 id="响应状态码含义">响应状态码含义</h2><ul>
<li>◆200 (OK): 找到了该资源，并且一切正常。</li>
<li>◆304 (NOT MODIFIED): 该资源在上次请求之后没有任何修改。这通常用于浏览器的缓存机制。</li>
<li>◆401 (UNAUTHORIZED): 客户端无权访问该资源。这通常会使得浏览器要求用户输入用户名和密码，以登录到服务器。</li>
<li>◆403 (FORBIDDEN): 客户端未能获得授权。这通常是在401之后输入了不正确的用户名或密码。</li>
<li>◆404 (NOT FOUND): 在指定的位置不存在所申请的资源。<br>）。</li>
</ul>
<h2 id="Http请求时要添加权限！！！">Http请求时要添加权限！！！</h2><p>找了一下午真是活该！<br>没加权限竟然。</p>
<pre><code><span class="number">07</span>-<span class="number">18</span> <span class="number">09</span>:<span class="number">05</span>:<span class="number">31.824</span>    <span class="number">1781</span>-<span class="number">1794</span>/com<span class="class">.zsz</span><span class="class">.develop</span><span class="class">.myrobot</span> E/AndroidRuntime﹕ FATAL EXCEPTION: AsyncTask #<span class="number">1</span>
java<span class="class">.lang</span><span class="class">.RuntimeException</span>: An error occured while executing <span class="function"><span class="title">doInBackground</span><span class="params">()</span></span>
</code></pre><p>错误行数在</p>
<pre><code><span class="attribute">httpResponse</span>=<span class="string"> httpClient.execute(httpGet);</span>
</code></pre><p>和</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">HttpData</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AsyncTask&lt;String</span>, <span class="title">Void</span>, <span class="title">String&gt;</span> {</span>
</code></pre><p>下回涨点记性</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/07/15/2015-7-15/" data-id="cie9kmo3400166ob2dwzajj2p" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


    
      <article id="post-2015-7-13-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/13/2015-7-13-2/">获取上下文路径，get和post</a>
    </h1>
  

        <div class="article-meta">
          <div class="article-date">
  <i class="fa fa-calendar"></i>
  <a href="/2015/07/13/2015-7-13-2/">
    <time datetime="2015-07-13T09:09:29.000Z" itemprop="datePublished">2015-07-13</time>
  </a>
</div>
          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="问题集">问题集</h1><h2 id="request-getContextPath()获取上下文路径">request.getContextPath()获取上下文路径</h2><p>超级实用的小技巧</p>
<p>《form action=”&lt;%=request.getContextPath() %&gt;/loginServlet” method=”post”&gt;</p>
<h2 id="Servlet添加到web。xml中的信息">Servlet添加到web。xml中的信息</h2><p>其中url中的值要与上面相对应。<br>    <servlet><br>          <servlet-name>LoginServlet</servlet-name><br>          <servlet-class>com.zsz.develop.servlet.LoginServlet</servlet-class><br>      </servlet></p>
<pre><code><span class="tag">&lt;<span class="title">servlet-mapping</span>&gt;</span>
    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>LoginServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/loginServlet<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span>
<span class="tag">&lt;/<span class="title">servlet-mapping</span>&gt;</span>
</code></pre><h2 id="get和post">get和post</h2><p><img src="http://cl.ly/image/2A2O3e2H3v27/E%7BKO]~HE348]90%252~9%7D9HGS.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/07/13/2015-7-13-2/" data-id="cie9kmo3b00186ob2pxemqc1r" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


    
      <article id="post-2015-7-13" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/12/2015-7-13/">JDBC API，JDBC Driver API，JDBC的操作流程，事务的四个特征，JDBC事务处理</a>
    </h1>
  

        <div class="article-meta">
          <div class="article-date">
  <i class="fa fa-calendar"></i>
  <a href="/2015/07/12/2015-7-13/">
    <time datetime="2015-07-12T11:31:21.000Z" itemprop="datePublished">2015-07-12</time>
  </a>
</div>
          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="7-13日问题集">7.13日问题集</h1><h2 id="JDBC_API">JDBC API</h2><p>DriverManager：这是一个驱动程序管理类，用来装载驱动程序。并为创建数据库连接提供支持</p>
<ul>
<li><p>Connection：connection是一个接口，用来连接某一特定的数据库。</p>
</li>
<li><p>Statement：statement接口提供了执行SQL语句。获取查询结果的方法</p>
</li>
<li><p>PreparedStatement：是statement的子接口，用来执行编译的sql语句</p>
</li>
<li><p>ResultSet：该接口提供了对结果集的处理方法</p>
</li>
</ul>
<h2 id="JDBC_Driver_API">JDBC Driver API</h2><p>JDBC Driver API是面向驱动程序开发商的接口</p>
<p>主要有四种:</p>
<ul>
<li>JDBC-ODBC bridge：这种驱动程序会把jdbc的调用委托给其他接口</li>
<li>部分java技术的本地api驱动程序</li>
<li>全部基于java技术的本地api驱动程序</li>
<li>全部基于java技术的本地协议驱动程序</li>
</ul>
<h2 id="JDBC的操作流程">JDBC的操作流程</h2><p><img src="http://cl.ly/image/0X0q2w0F3l2M/Image%202015-07-13%20at%201.38.03%20%E4%B8%8B%E5%8D%88.png" alt=""></p>
<h2 id="Class-forName（）">Class.forName（）</h2><p>Class：这个类封装了要装载到JVM中类的信息。比如类的成员方法，成员变量，以及这个类实现的接口。</p>
<p>forName（）：这个方法用来初始化指定参数的类。并创建一个对应的实例对象</p>
<p>参数中的字符串：是mysql指定的字符串驱动程序</p>
<h2 id="事务的四个特征">事务的四个特征</h2><p>事务是作为一个逻辑单元执行的一系列操作，一个逻辑工作单元必须有四个属性，称为 ACID（原子性、一致性、隔离性和持久性）属性，只有这样才能成为一个事务：</p>
<ul>
<li><p>原子性<br>事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。</p>
</li>
<li><p>一致性<br>事务在完成时，必须使所有的数据都保持一致状态。在相关数据库中，所有规则都必须应用于事务的修改，以保持所有数据的完整性。事务结束时，所有的内部数据结构（如 B 树索引或双向链表）都必须是正确的。</p>
</li>
<li><p>隔离性<br>由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看中间状态的数据。这称为可串行性，因为它能够重新装载起始数据，并且重播一系列事务，以使数据结束时的状态与原始事务执行的状态相同。</p>
</li>
<li><p>持久性<br>事务完成之后，它对于系统的影响是永久性的。该修改即使出现系统故障也将一直保持。</p>
</li>
</ul>
<h2 id="JDBC事务处理">JDBC事务处理</h2><p><a href="http://blog.csdn.net/csc0211/article/details/6232047" title="JDBC事务处理" target="_blank" rel="external">http://blog.csdn.net/csc0211/article/details/6232047</a></p>
<blockquote>
<p>在JDBC的数据库操作中，一项事务是由一条或是多条表达式所组成的一个不可分割的工作单元。我们通过提交commit()或是回退rollback()来结束事务的操作。关于事务操作的方法都位于接口java.sql.Connection中。</p>
<p>首先我们要注意，在JDBC中，事务操作默认是自动提交。也就是说，一条对数据库的更新表达式代表一项事务操作。操作成功后，系统将自动调用commit()来提交，否则将调用rollback()来回退。<br>    其次，在JDBC中，可以通过调用setAutoCommit(false)来禁止自动提交。之后就可以把多个数据库操作的表达式作为一个事务，在操作完成后调用commit()来进行整体提交。倘若其中一个表达式操作失败，都不会执行到commit()，并且将产生响应的异常。此时就可以在异常捕获时调用rollback()进行回退。这样做可以保持多次更新操作后，相关数据的一致性。<br>    具体事例如下：</p>
</blockquote>
<pre><code>        <span class="keyword">try</span> {
    <span class="keyword">Class</span>.forName(<span class="string">"oracle.jdbc.driver.OracleDriver"</span>);
    conn = DriverManager.getConnection(<span class="string">"jdbc:oracle:thin:@127.0.0.1:1521:luecc"</span>, <span class="string">"scott"</span>, <span class="string">"tiger"</span>);
                <span class="comment">//点禁止自动提交，设置回退</span>
    conn.setAutoCommit(<span class="keyword">false</span>);
    stmt = conn.createStatement();
                <span class="comment">//数据更新</span>
    stmt.addBatch(<span class="string">"insert into dept values (51, '500', 'ccc')"</span>);
    stmt.addBatch(<span class="string">"insert into dept values (52, '600', 'ddd')"</span>);
    stmt.addBatch(<span class="string">"insert into dept values (53, '700', 'eee')"</span>);
    stmt.executeBatch();
                <span class="comment">//事务提交 </span>
    conn.commit();
    conn.setAutoCommit(<span class="keyword">true</span>);
} <span class="keyword">catch</span> (ClassNotFoundException e) {
    e.printStackTrace();
} <span class="keyword">catch</span>(SQLException e) {
    e.printStackTrace();
    <span class="keyword">try</span> {
        <span class="keyword">if</span>(conn != <span class="keyword">null</span>)
        {
                                <span class="comment">//操作不成功则回退</span>
            conn.rollback();
                                <span class="comment">//重新设置恢复默认值</span>
            conn.setAutoCommit(<span class="keyword">true</span>);
        }
    } <span class="keyword">catch</span> (SQLException e1) {
        e1.printStackTrace();
    }
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/07/12/2015-7-13/" data-id="cie9kmo3700176ob24rc8vpy1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


    
      <article id="post-2015-7-12" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/12/2015-7-12/">For-Each循环，两种方式实现插入，增删改查，完整的JDBC代码</a>
    </h1>
  

        <div class="article-meta">
          <div class="article-date">
  <i class="fa fa-calendar"></i>
  <a href="/2015/07/12/2015-7-12/">
    <time datetime="2015-07-12T01:35:24.000Z" itemprop="datePublished">2015-07-12</time>
  </a>
</div>
          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="7-12问题集">7.12问题集</h1><h2 id="For-Each循环">For-Each循环</h2><p>Java[編輯]<br>Java語言從JDK 1.5.0開始引入foreach循環。</p>
<p>以下代碼用於循環列印myArray數組中的每個元素，java中的foreach循環使用for關鍵字，而非foreach。</p>
<pre><code><span class="tag">for</span> (<span class="tag">int</span> <span class="rule"><span class="attribute">x </span>:<span class="value"> myArray){
  System.out.<span class="function">println</span>(x)</span></span>;
}
</code></pre><p>他的语法如下</p>
<pre><code><span class="tag">for</span>(<span class="tag">type</span> <span class="rule"><span class="attribute">element</span>:<span class="value"> array)

　　{

  　System.out.<span class="function">println</span>(element)</span></span>;

　　}
</code></pre><h2 id="两种方式实现插入">两种方式实现插入</h2><p>第一种直接书写sql语句。</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(UserInfo userInfo)</span></span>{
    Connection conn=BaseConnection.getConnection();
    PreparedStatement ps=<span class="keyword">null</span>;
    <span class="keyword">try</span> {

        String sqlinsert=<span class="string">"insert into userinfo(name,password)"</span>+ <span class="string">"values('"</span>+userInfo.getName()+<span class="string">"','"</span>+userInfo.getPassword()+<span class="string">"')"</span>;
        System.<span class="keyword">out</span>.println(sqlinsert);
        ps=(PreparedStatement) conn.prepareStatement(sqlinsert);

        <span class="comment">//注意：这里不要传入参数（），executeUpdate（）增删改都使用者种方法。</span>
        <span class="keyword">int</span> i=ps.executeUpdate();
        <span class="keyword">if</span> (i&gt;<span class="number">0</span>) {
            System.<span class="keyword">out</span>.println(<span class="string">"添加成功"</span>);
        }<span class="keyword">else</span> {
            System.<span class="keyword">out</span>.println(<span class="string">"添加失败"</span>);
        }

    } <span class="keyword">catch</span> (SQLException e) {
        <span class="comment">// TODO Auto-generated catch block</span>
        e.printStackTrace();
    }<span class="keyword">finally</span>{
        <span class="comment">//rs.ps.conn都是跟数据库连接相关的。当我们使用完毕，必须关闭资源，防止堵死。顺序的后打开先关闭</span>
        <span class="keyword">try</span> {

            <span class="keyword">if</span> (ps!=<span class="keyword">null</span>) {
                ps.close();
            }
            <span class="keyword">if</span> (conn!=<span class="keyword">null</span>) {
                conn.close();
            }
        } <span class="keyword">catch</span> (SQLException e) {
            <span class="comment">// TODO Auto-generated catch block</span>
            e.printStackTrace();

        }
    }
}
</code></pre><p>第二种使用占位符书写</p>
<pre><code><span class="comment">/*
 *占位符的优势。
 *1.效率更高
 *2.书写时不容易出错
 *3.防止sql注入（安全问题） 
 */</span>


<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert2</span><span class="params">(UserInfo userInfo)</span></span>{
    Connection conn=BaseConnection.getConnection();
    PreparedStatement ps=<span class="keyword">null</span>;
    <span class="keyword">try</span> {

        String sqlinsert=<span class="string">"insert into userinfo(name,password)"</span>+ <span class="string">"values(?,?)"</span>;
        System.<span class="keyword">out</span>.println(sqlinsert);
        ps=(PreparedStatement) conn.prepareStatement(sqlinsert);
        ps.setString(<span class="number">1</span>, userInfo.getName());
        ps.setString(<span class="number">2</span>, userInfo.getPassword());
        <span class="comment">//注意：这里不要传入参数（），executeUpdate（）增删改都使用者种方法。</span>
        <span class="keyword">int</span> i=ps.executeUpdate();
        <span class="keyword">if</span> (i&gt;<span class="number">0</span>) {
            System.<span class="keyword">out</span>.println(<span class="string">"添加成功"</span>);
        }<span class="keyword">else</span> {
            System.<span class="keyword">out</span>.println(<span class="string">"添加失败"</span>);
        }

    } <span class="keyword">catch</span> (SQLException e) {
        <span class="comment">// TODO Auto-generated catch block</span>
        e.printStackTrace();
    }<span class="keyword">finally</span>{
        <span class="comment">//rs.ps.conn都是跟数据库连接相关的。当我们使用完毕，必须关闭资源，防止堵死。顺序的后打开先关闭</span>
        <span class="keyword">try</span> {

            <span class="keyword">if</span> (ps!=<span class="keyword">null</span>) {
                ps.close();
            }
            <span class="keyword">if</span> (conn!=<span class="keyword">null</span>) {
                conn.close();
            }
            } <span class="keyword">catch</span> (SQLException e) {
            <span class="comment">// TODO Auto-generated catch block</span>
            e.printStackTrace();

    }
}
}
</code></pre><p>他的调用我也补充一下</p>
<pre><code>public static void main(<span class="type">String</span><span class="literal">[]</span> args) {
        <span class="type">ArrayList</span>&lt;<span class="type">UserInfo</span>&gt; arrayList= <span class="keyword">new</span> <span class="type">UserInfoDao</span><span class="literal">()</span>.getList<span class="literal">()</span>;
        <span class="type">UserInfo</span> userInfo=<span class="keyword">new</span> <span class="type">UserInfo</span><span class="literal">()</span>;
        userInfo.setName(<span class="string">"shan"</span>);
        userInfo.setPassword(<span class="string">"123---"</span>);
        <span class="keyword">new</span> <span class="type">UserInfoDao</span><span class="literal">()</span>.insert(userInfo);

    }

}
</code></pre><h2 id="更新操作">更新操作</h2><pre><code><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(UserInfo userInfo)</span></span>{
    Connection conn=BaseConnection.getConnection();
    PreparedStatement ps=<span class="keyword">null</span>;
    String updateSQL=<span class="string">"update userinfo set name=?,password=?"</span>+<span class="string">"where id=?"</span>;

    <span class="keyword">try</span> {
        ps=(PreparedStatement) conn.prepareStatement(updateSQL);
        ps.setString(<span class="number">1</span>, userInfo.getName());
        ps.setString(<span class="number">2</span>, userInfo.getPassword());
        ps.setInt(<span class="number">3</span>, userInfo.getId());
        System.<span class="keyword">out</span>.println(updateSQL);

        <span class="keyword">int</span> a=ps.executeUpdate();
        <span class="keyword">if</span> (a&gt;<span class="number">0</span>) {
            System.<span class="keyword">out</span>.println(<span class="string">"更改完成"</span>);
        }
        <span class="keyword">if</span> (a&lt;<span class="number">0</span>) {
            System.<span class="keyword">out</span>.println(<span class="string">"更改失败"</span>);

        }
    } <span class="keyword">catch</span> (SQLException e) {
        <span class="comment">// TODO Auto-generated catch block</span>
        e.printStackTrace();
    }<span class="keyword">finally</span>{
            <span class="keyword">try</span> {
                <span class="keyword">if</span> (ps!=<span class="keyword">null</span>) {
                    ps.close();
                }
                <span class="keyword">if</span> (conn!=<span class="keyword">null</span>) {
                    conn.close();
                }
            } <span class="keyword">catch</span> (SQLException e) {
                <span class="comment">// TODO Auto-generated catch block</span>
                e.printStackTrace();
            }

    }

}
</code></pre><p>注意点：ps.setString(1, userInfo.getName());这是从1开始添加。</p>
<h2 id="删除数据">删除数据</h2><pre><code><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span> </span>{
    Connection conn=BaseConnection.getConnection();
    PreparedStatement ps=<span class="keyword">null</span>;
    String deleteSQL=<span class="string">"delete from userinfo where id=?"</span>;

    <span class="keyword">try</span> {
        ps=(PreparedStatement) conn.prepareStatement(deleteSQL);
        ps.setInt(<span class="number">1</span>, id);
        <span class="keyword">int</span> a=ps.executeUpdate();
        <span class="keyword">if</span> (a&gt;<span class="number">0</span>) {
            System.<span class="keyword">out</span>.println(<span class="string">"删除成功"</span>);
        }<span class="keyword">else</span> {
            System.<span class="keyword">out</span>.println(<span class="string">"删除失败"</span>);
        }
    } <span class="keyword">catch</span> (Exception e) {
        e.printStackTrace();
    }<span class="keyword">finally</span>{
        <span class="keyword">try</span> {
            <span class="keyword">if</span> (ps!=<span class="keyword">null</span>) {
                ps.close();
            }
            <span class="keyword">if</span> (conn!=<span class="keyword">null</span>) {
                conn.close();
            }
        } <span class="keyword">catch</span> (Exception e2) {
            e2.printStackTrace();
        }
    }
}
</code></pre><h2 id="进行代码优化——1，关闭资源">进行代码优化——1，关闭资源</h2><p>注意：参数有两个或者三个的。这时候就要使用参数多态性</p>
<p>当使用的时候就直接调用者两个函数就可以了<br>    public static void closeResource(PreparedStatement ps,Connection conn){</p>
<pre><code>    <span class="keyword">try</span> {
        <span class="keyword">if</span> (ps!=<span class="keyword">null</span>) {
            ps.close();
        }
        <span class="keyword">if</span> (conn!=<span class="keyword">null</span>) {
            conn.close();
        }
        } <span class="keyword">catch</span> (SQLException e) {
        <span class="comment">// TODO Auto-generated catch block</span>
        e.printStackTrace();
        }
}

<span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">closeResource</span><span class="params">(ResultSet rs,PreparedStatement ps,Connection conn)</span></span>{

    <span class="keyword">try</span> {
        <span class="keyword">if</span> (rs!=<span class="keyword">null</span>) {
        rs.close();

        }
        <span class="keyword">if</span> (ps!=<span class="keyword">null</span>) {
            ps.close();
        }
        <span class="keyword">if</span> (conn!=<span class="keyword">null</span>) {
            conn.close();
        }
        } <span class="keyword">catch</span> (SQLException e) {
        <span class="comment">// TODO Auto-generated catch block</span>
        e.printStackTrace();
        }
}
</code></pre><h2 id="代码优化之二———使用boolean值作为返回值来判断是否修改成功">代码优化之二———使用boolean值作为返回值来判断是否修改成功</h2><p>前面的修改例子中，修改成功是显示在控制台上。而这种方法修改成功是显示在返回值</p>
<pre><code><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="keyword">delete</span>(<span class="keyword">int</span> id) {
    <span class="keyword">boolean</span> b=<span class="keyword">false</span>;
    Connection conn=BaseConnection.getConnection();
    PreparedStatement ps=<span class="keyword">null</span>;
    String deleteSQL=<span class="string">"delete from userinfo where id=?"</span>;

    <span class="keyword">try</span> {
        ps=(PreparedStatement) conn.prepareStatement(deleteSQL);
        ps.setInt(<span class="number">1</span>, id);
        <span class="keyword">int</span> a=ps.executeUpdate();
        <span class="keyword">if</span> (a&gt;<span class="number">0</span>) {
            b=<span class="keyword">true</span>;
        }<span class="keyword">else</span> {
            System.out.<span class="keyword">println</span>(<span class="string">"删除失败"</span>);
        }
    } <span class="keyword">catch</span> (Exception e) {
        e.printStackTrace();
    }<span class="keyword">finally</span>{
        BaseConnection.closeResource(ps, conn);
    }
    <span class="keyword">return</span> b;
}
</code></pre><h2 id="完整的JDBC代码">完整的JDBC代码</h2><pre><code><span class="keyword">package</span> com.zsz.develop.dao;

<span class="keyword">import</span> java.sql.Connection;
<span class="keyword">import</span> java.sql.ResultSet;
<span class="keyword">import</span> java.sql.SQLException;
<span class="keyword">import</span> java.util.ArrayList;
<span class="keyword">import</span> java.util.Iterator;

<span class="keyword">import</span> org.omg.CORBA.portable.ValueBase;
<span class="keyword">import</span> org.omg.PortableServer.ID_ASSIGNMENT_POLICY_ID;

<span class="keyword">import</span> com.mysql.jdbc.PreparedStatement;
<span class="keyword">import</span> com.zsz.develop.bean.UserInfo;
<span class="keyword">import</span> com.zsz.develop.util.BaseConnection;

<span class="keyword">public</span> class UserInfoDao {

<span class="keyword">public</span> ArrayList&lt;UserInfo&gt; getList(){
    ArrayList&lt;UserInfo&gt; arrayList=<span class="keyword">new</span> ArrayList&lt;UserInfo&gt;();
    Connection conn=BaseConnection.getConnection();
    <span class="comment">//定义在外面是要让他成为全局变量</span>
    PreparedStatement ps=<span class="keyword">null</span>;
    ResultSet rs=<span class="keyword">null</span>;
    <span class="keyword">String</span> sql=<span class="string">"select * from userinfo"</span>;

    <span class="keyword">try</span> {
        ps=(PreparedStatement) conn.prepareStatement(sql);
         rs =ps.executeQuery();
        <span class="keyword">while</span> (rs.next()) {
<span class="comment">//                System.out.println(rs.getString("name")+"-----");</span>
            <span class="comment">//把数据封装到实体类</span>
            UserInfo userInfo=<span class="keyword">new</span> UserInfo();
            userInfo.setId(rs.getInt(<span class="string">"id"</span>));
            userInfo.setName(rs.getString(<span class="string">"name"</span>));
            userInfo.setPassword(rs.getString(<span class="string">"password"</span>));
            <span class="comment">//再把封装好的对象放到我们的集合中去</span>
            arrayList.<span class="built_in">add</span>(userInfo);
        }




    } <span class="keyword">catch</span> (SQLException e) {
        <span class="comment">// TODO Auto-generated catch block</span>
        e.printStackTrace();
    }<span class="keyword">finally</span>{
        <span class="comment">//rs.ps.conn都是跟数据库连接相关的。当我们使用完毕，必须关闭资源，防止堵死。顺序的后打开先关闭</span>
            BaseConnection.closeResource(rs, ps, conn);
    }

    <span class="keyword">return</span> arrayList;
}

<span class="keyword">public</span> <span class="built_in">boolean</span> insert(UserInfo userInfo){
    <span class="built_in">boolean</span> b=<span class="keyword">false</span>;
    Connection conn=BaseConnection.getConnection();
    PreparedStatement ps=<span class="keyword">null</span>;
    <span class="keyword">try</span> {

        <span class="keyword">String</span> sqlinsert=<span class="string">"insert into userinfo(name,password)"</span>+ <span class="string">"values('"</span>+userInfo.getName()+<span class="string">"','"</span>+userInfo.getPassword()+<span class="string">"')"</span>;
        System.out.<span class="built_in">println</span>(sqlinsert);
        ps=(PreparedStatement) conn.prepareStatement(sqlinsert);

        <span class="comment">//注意：这里不要传入参数（），executeUpdate（）增删改都使用者种方法。</span>
        <span class="built_in">int</span> i=ps.executeUpdate();
        <span class="keyword">if</span> (i&gt;<span class="number">0</span>) {
            b=<span class="keyword">true</span>;
        }

    } <span class="keyword">catch</span> (SQLException e) {
        <span class="comment">// TODO Auto-generated catch block</span>
        e.printStackTrace();
    }<span class="keyword">finally</span>{
        BaseConnection.closeResource( ps, conn);
    }
    <span class="keyword">return</span> b;
}
<span class="comment">/*
 *占位符的优势。
 *1.效率更高
 *2.书写时不容易出错
 *3.防止sql注入（安全问题） 
 */</span>


<span class="keyword">public</span> <span class="built_in">boolean</span> insert2(UserInfo userInfo){
    <span class="built_in">boolean</span> b=<span class="keyword">false</span>;
    Connection conn=BaseConnection.getConnection();
    PreparedStatement ps=<span class="keyword">null</span>;
    <span class="keyword">try</span> {

        <span class="keyword">String</span> sqlinsert=<span class="string">"insert into userinfo(name,password)"</span>+ <span class="string">"values(?,?)"</span>;
        System.out.<span class="built_in">println</span>(sqlinsert);
        ps=(PreparedStatement) conn.prepareStatement(sqlinsert);
        ps.setString(<span class="number">1</span>, userInfo.getName());
        ps.setString(<span class="number">2</span>, userInfo.getPassword());
        <span class="comment">//注意：这里不要传入参数（），executeUpdate（）增删改都使用者种方法。</span>
        <span class="built_in">int</span> i=ps.executeUpdate();
        <span class="keyword">if</span> (i&gt;<span class="number">0</span>) {
            b=<span class="keyword">true</span>;
        }<span class="keyword">else</span> {
            System.out.<span class="built_in">println</span>(<span class="string">"添加失败"</span>);
        }

    } <span class="keyword">catch</span> (SQLException e) {
        <span class="comment">// TODO Auto-generated catch block</span>
        e.printStackTrace();
    }<span class="keyword">finally</span>{
        <span class="comment">//rs.ps.conn都是跟数据库连接相关的。当我们使用完毕，必须关闭资源，防止堵死。顺序的后打开先关闭</span>
        BaseConnection.closeResource(ps, conn);

    }
    <span class="keyword">return</span> b;
}


<span class="keyword">public</span> <span class="built_in">boolean</span> update(UserInfo userInfo){
    <span class="built_in">boolean</span> b=<span class="keyword">false</span>;
    Connection conn=BaseConnection.getConnection();
    PreparedStatement ps=<span class="keyword">null</span>;
    <span class="keyword">String</span> updateSQL=<span class="string">"update userinfo set name=?,password=?"</span>+<span class="string">"where id=?"</span>;

    <span class="keyword">try</span> {
        ps=(PreparedStatement) conn.prepareStatement(updateSQL);
        ps.setString(<span class="number">1</span>, userInfo.getName());
        ps.setString(<span class="number">2</span>, userInfo.getPassword());
        ps.setInt(<span class="number">3</span>, userInfo.getId());
        System.out.<span class="built_in">println</span>(updateSQL);

        <span class="built_in">int</span> a=ps.executeUpdate();
        <span class="keyword">if</span> (a&gt;<span class="number">0</span>) {
            b=<span class="keyword">true</span>;
        }



    } <span class="keyword">catch</span> (SQLException e) {
        <span class="comment">// TODO Auto-generated catch block</span>
        e.printStackTrace();
    }<span class="keyword">finally</span>{
            BaseConnection.closeResource(ps, conn);

    }
    <span class="keyword">return</span> b;
}

<span class="keyword">public</span> <span class="built_in">boolean</span> delete(<span class="built_in">int</span> id) {
    <span class="built_in">boolean</span> b=<span class="keyword">false</span>;
    Connection conn=BaseConnection.getConnection();
    PreparedStatement ps=<span class="keyword">null</span>;
    <span class="keyword">String</span> deleteSQL=<span class="string">"delete from userinfo where id=?"</span>;

    <span class="keyword">try</span> {
        ps=(PreparedStatement) conn.prepareStatement(deleteSQL);
        ps.setInt(<span class="number">1</span>, id);
        <span class="built_in">int</span> a=ps.executeUpdate();
        <span class="keyword">if</span> (a&gt;<span class="number">0</span>) {
            b=<span class="keyword">true</span>;
        }<span class="keyword">else</span> {
            System.out.<span class="built_in">println</span>(<span class="string">"删除失败"</span>);
        }
    } <span class="keyword">catch</span> (Exception e) {
        e.printStackTrace();
    }<span class="keyword">finally</span>{
        BaseConnection.closeResource(ps, conn);
    }
    <span class="keyword">return</span> b;
}



}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/07/12/2015-7-12/" data-id="cie9kmo3d00196ob20l4gzk97" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


    
      <article id="post-2015-7-11" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/11/2015-7-11/">连接数据库代码，为什么静态类方法可以直接调用？，.PreparedStatement和Statement的使用，结果集(ResultSet)用法</a>
    </h1>
  

        <div class="article-meta">
          <div class="article-date">
  <i class="fa fa-calendar"></i>
  <a href="/2015/07/11/2015-7-11/">
    <time datetime="2015-07-11T10:25:33.000Z" itemprop="datePublished">2015-07-11</time>
  </a>
</div>
          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="711问题集">711问题集</h1><ul>
<li>1.The local variable conn may not have been initialized<h2 id="局部变量没有初始化问题？">局部变量没有初始化问题？</h2></li>
</ul>
<p>局部变量在进行读取操作之前必须进行初始化或进行赋值操作,否则会出现编译错误.</p>
<h2 id="-_2-连接数据库代码">- 2.连接数据库代码</h2><pre><code>package com.zsz.develop.util;
<span class="preprocessor"><span class="keyword">import</span> java.sql.Connection;</span>
<span class="preprocessor"><span class="keyword">import</span> java.sql.DriverManager;</span>
<span class="preprocessor"><span class="keyword">import</span> java.sql.SQLException;</span>

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseConnection</span> {</span>

<span class="keyword">public</span> static Connection getConnection(){    

    Connection conn=<span class="literal">null</span>;
    <span class="keyword">try</span> {
        <span class="class"><span class="keyword">Class</span>.<span class="title">forName</span>("<span class="title">com</span>.<span class="title">mysql</span>.<span class="title">jdbc</span>.<span class="title">Driver</span>");</span>
        conn=DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/test"</span>, <span class="string">"root"</span>, <span class="string">"SF948640."</span>);
    } <span class="keyword">catch</span> (ClassNotFoundException e) {
        // TODO Auto-generated <span class="keyword">catch</span> block
        e.printStackTrace();
    } <span class="keyword">catch</span> (SQLException e) {
        // TODO Auto-generated <span class="keyword">catch</span> block
        e.printStackTrace();
    }

    <span class="keyword">return</span> conn;
}

}
</code></pre><h2 id="-_3-为什么静态类方法可以直接调用？">- 3.为什么静态类方法可以直接调用？</h2><p>这是因为静态类方法实际上属于类，不同任何类实例相关，也不允许访问任何实例属性；因此这些方法可以共享，可以直接调用；而普通方法需要同类实例相关，因此必须在对应的实例中访问。</p>
<pre><code>    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
<span class="comment">//当connection成为静态时、就可以直接调用。</span>
<span class="comment">//        Connection conn=new BaseConnection().getConnection();</span>
    Connection conn=BaseConnection.getConnection();
    System.<span class="keyword">out</span>.println(conn);
}
</code></pre><h2 id="-_4-PreparedStatement和Statement的使用">- 4.PreparedStatement和Statement的使用</h2><p>PreparedStatement和Statement都是SQL执行器对象。PreparedStatement 对象已预编译过(所以第一次执行花费更多时间)，所以其执行速度要快于 Statement 对象。</p>
<p>JDBC驱动的最佳化是基于使用的是什么功能. 选择PreparedStatement还是Statement取决于你要怎么使用它们. 对于只执行一次的SQL语句选择Statement是最好的. 相反, 如果SQL语句被多次执行选用PreparedStatement是最好的.</p>
<h2 id="-_5-结果集(ResultSet)用法">- 5.结果集(ResultSet)用法</h2><p>ResultSet，数据库结果集的数据表，通常通过执行查询数据库的语句生成。</p>
<p>ResultSet里面是一个指针数据，他首先指向0位置，也就是标题。当他使用next（）时。他读取的才是真正的数据。然后通过0位置的标题对比逐个取出数据</p>
<p>简单实例</p>
<pre><code>    <span class="function"><span class="keyword">public</span> ArrayList&lt;UserInfoDao&gt; <span class="title">getList</span><span class="params">()</span></span>{
    ArrayList&lt;UserInfoDao&gt; arrayList=<span class="keyword">new</span> ArrayList&lt;UserInfoDao&gt;();
    Connection conn=BaseConnection.getConnection();
    <span class="comment">//sql执行器Statement</span>
    PreparedStatement ps=<span class="keyword">null</span>;
    <span class="comment">//ResultSet结果集对象</span>
    String sql=<span class="string">"select * from userinfo"</span>;
    <span class="keyword">try</span> {
        ps=ps=(PreparedStatement) conn.prepareStatement(sql);
        rs =ps.executeQuery();
        <span class="keyword">while</span> (rs.next()) {
            System.<span class="keyword">out</span>.println(rs.getString(<span class="string">"name"</span>)+<span class="string">"-----"</span>);
        }

    } <span class="keyword">catch</span> (SQLException e) {
        <span class="comment">// TODO Auto-generated catch block</span>
        e.printStackTrace();
    }

    <span class="keyword">return</span> arrayList;
}
</code></pre><p>把他存进实体类，再读取出来的案例</p>
<pre><code>package com.zsz.develop.dao;

<span class="keyword">import</span> java.sql.Connection;
<span class="keyword">import</span> java.sql.ResultSet;
<span class="keyword">import</span> java.sql.SQLException;
<span class="keyword">import</span> java.util.ArrayList;
<span class="keyword">import</span> java.util.Iterator;

<span class="keyword">import</span> com.mysql.jdbc.PreparedStatement;
<span class="keyword">import</span> com.zsz.develop.bean.UserInfo;
<span class="keyword">import</span> com.zsz.develop.util.BaseConnection;

public <span class="class"><span class="keyword">class</span> <span class="title">UserInfoDao</span> </span>{

public ArrayList&lt;UserInfo&gt; getList(){
    ArrayList&lt;UserInfo&gt; arrayList=<span class="keyword">new</span> ArrayList&lt;UserInfo&gt;();
    Connection conn=BaseConnection.getConnection();
    PreparedStatement ps=<span class="literal">null</span>;

    <span class="built_in">String</span> sql=<span class="string">"select * from userinfo"</span>;
    <span class="keyword">try</span> {
        ps=(PreparedStatement) conn.prepareStatement(sql);
        ResultSet rs =ps.executeQuery();
        <span class="keyword">while</span> (rs.next()) {
<span class="comment">//                System.out.println(rs.getString("name")+"-----");</span>
            <span class="comment">//把数据封装到实体类</span>
            UserInfo userInfo=<span class="keyword">new</span> UserInfo();
            userInfo.setId(rs.getInt(<span class="string">"id"</span>));
            userInfo.setName(rs.getString(<span class="string">"name"</span>));
            userInfo.setPassword(rs.getString(<span class="string">"password"</span>));
            <span class="comment">//再把封装好的对象放到我们的集合中去</span>
            arrayList.add(userInfo);
        }

    } <span class="keyword">catch</span> (SQLException e) {
        <span class="comment">// TODO Auto-generated catch block</span>
        e.printStackTrace();
    }

    <span class="keyword">return</span> arrayList;
}
<span class="comment">//添加再其他地方既可以使用。</span>
<span class="comment">//    public static void main(String[] args) {</span>
<span class="comment">//        ArrayList&lt;UserInfo&gt; arrayList= new UserInfoDao().getList();</span>
<span class="comment">//        //用新型for循环把他打印出来</span>
<span class="comment">//        for(UserInfo userInfo:arrayList){</span>
<span class="comment">//            System.out.println(userInfo.getId()+"  "+userInfo.getName()+"  "+userInfo.getPassword());</span>
<span class="comment">//        }</span>
<span class="comment">//    }</span>

}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/07/11/2015-7-11/" data-id="cie9kmo3f001a6ob2s5e0bp3m" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


    
      <article id="post-2015-6-8" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/08/2015-6-8/">Android传数据到服务器端</a>
    </h1>
  

        <div class="article-meta">
          <div class="article-date">
  <i class="fa fa-calendar"></i>
  <a href="/2015/06/08/2015-6-8/">
    <time datetime="2015-06-08T07:24:12.000Z" itemprop="datePublished">2015-06-08</time>
  </a>
</div>
          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Android传数据到服务器端">Android传数据到服务器端</h1><p>在之前的博客中提到主线程中不能操作耗时的操作，例如网络操作。</p>
<p>今天使用实例来使用AsnycTask。</p>
<pre><code> public <span class="type">Robot</span> query(<span class="type">Robot</span> rqRobot) {

    <span class="type">Gson</span> gson=<span class="keyword">new</span> <span class="type">Gson</span><span class="literal">()</span>;
    <span class="type">String</span> url= <span class="type">MyData</span>.<span class="type">URL</span>+<span class="string">"RobotServlet"</span>;
    <span class="type">HttpClient</span> client=<span class="keyword">new</span> <span class="type">DefaultHttpClient</span><span class="literal">()</span>;
    <span class="type">HttpPost</span> post=<span class="keyword">new</span> <span class="type">HttpPost</span>(url);
    <span class="type">List</span>&lt;<span class="type">NameValuePair</span>&gt; rqParmeter=<span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;<span class="literal">()</span>;
    rqParmeter.add(<span class="keyword">new</span> <span class="type">BasicNameValuePair</span>(<span class="string">"input"</span>,gson.toJson(rqRobot)));
    <span class="keyword">try</span> {
        post.setEntity(<span class="keyword">new</span> <span class="type">UrlEncodedFormEntity</span>(rqParmeter, <span class="type">HTTP</span>.<span class="type">UTF_8</span>));

    } catch (<span class="type">UnsupportedEncodingException</span> e) {
        e.printStackTrace<span class="literal">()</span>;
    }

    <span class="type">Robot</span> rpRobot=null;
    <span class="type">Log</span>.e(<span class="string">"niinin"</span>,<span class="string">"----------------------------"</span>);

    <span class="keyword">try</span> {
        <span class="type">HttpResponse</span> httpResponse=client.execute(post);
        <span class="built_in">int</span> statusCode=  httpResponse.getStatusLine<span class="literal">()</span>.getStatusCode<span class="literal">()</span>;

        <span class="type">Log</span>.e(<span class="string">"dsdsd"</span>,statusCode+<span class="string">""</span>);
        <span class="keyword">if</span> (statusCode==<span class="number">200</span>){
            <span class="type">HttpEntity</span> httpEntity= httpResponse.getEntity<span class="literal">()</span>;
            <span class="type">Log</span>.e(<span class="string">"niinin"</span>,httpResponse.getEntity<span class="literal">()</span>.toString<span class="literal">()</span>);
          rpRobot=gson.fromJson(<span class="type">EntityUtils</span>.toString(httpEntity),<span class="type">Robot</span>.<span class="keyword">class</span>);
        }
    } catch (<span class="type">IOException</span> e) {
        e.printStackTrace<span class="literal">()</span>;
    }

    return rpRobot;
}
</code></pre><p> 执行client上传数据，接收到的就是返回值：<br>HttpResponse response = client.execute(post);</p>
<p>得到返回值：response.getEntity()</p>
<p>但是得到的返回值不是字符串，要先把他转为字符串：</p>
<p>使用EntityUtils的方法来转化为字符串</p>
<p>EntityUtils.toString(response.getEntity());</p>
<pre><code> <span class="comment">// setting request parameters</span>
    List&lt;NameValuePair&gt; requestParameters = <span class="keyword">new</span> ArrayList&lt;&gt;();
    <span class="comment">// send imageSize parameter to server for recognition</span>
    requestParameters.<span class="built_in">add</span>(<span class="keyword">new</span> BasicNameValuePair(<span class="string">"action"</span>, <span class="string">"findById"</span>));
    requestParameters.<span class="built_in">add</span>(<span class="keyword">new</span> BasicNameValuePair(<span class="string">"imageSize"</span>, <span class="string">"400"</span>));
    requestParameters.<span class="built_in">add</span>(<span class="keyword">new</span> BasicNameValuePair(<span class="string">"id"</span>, Integer
            .toString(spotId)));

    <span class="keyword">try</span> {
<span class="comment">//要将list转化为转化为Entity，可以调用UrlEncodedFormEntity方法转化</span>
        post.setEntity(<span class="keyword">new</span> UrlEncodedFormEntity(requestParameters,
                HTTP.UTF_8));
</code></pre><p><a href="http://zszdevelop.github.io/2015/05/27/2015-5-27/" target="_blank" rel="external">http://zszdevelop.github.io/2015/05/27/2015-5-27/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/06/08/2015-6-8/" data-id="cie9kmo3i001b6ob2hr474bc9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


    
      <article id="post-2015-6-5-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/05/2015-6-5-2/">java集合的使用</a>
    </h1>
  

        <div class="article-meta">
          <div class="article-date">
  <i class="fa fa-calendar"></i>
  <a href="/2015/06/05/2015-6-5-2/">
    <time datetime="2015-06-05T03:06:22.000Z" itemprop="datePublished">2015-06-05</time>
  </a>
</div>
          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java集合">Java集合</h1><p>java集合接口（接口不能直接实例化、要实例化他的子类）：</p>
<ul>
<li>Collection 接口</li>
<li>List接口</li>
<li>Set接口</li>
<li>Iterator接口</li>
<li>Map接口</li>
</ul>
<h2 id="接口之间的关系图">接口之间的关系图</h2><p><img src="http://cl.ly/image/1F3P3E42350q/IC$HBD%601%7BZ2A%60S3K]L@C05V.png" alt="接口之间关系"></p>
<h2 id="集合">集合</h2><ul>
<li>1.集合可以理解为一个动态的对象数组，不同的是集合的对象内容可以任意扩充</li>
<li>2.集合的特点：<br> 性能高，容易扩展和修改<h2 id="List接口">List接口</h2>List继承自Collection</li>
<li>1.List接口可以存放任意的数据，而且在List接口中内容是可以重复的</li>
<li>2.List接口常用子类</li>
<li><ul>
<li>Arraylist</li>
<li>Vector</li>
</ul>
</li>
</ul>
<p>Arraylist和Vector的实现差不多，他们之间的区别就是</p>
<ul>
<li>Arraylist：采用异步处理方式，性能高，属于非线程安全。</li>
<li>Vector：采用同步处理方式，性能低，属于线程安全。</li>
</ul>
<p>ArrayList的简单实例</p>
<pre><code><span class="keyword">import</span> java.util.ArrayList;
<span class="keyword">import</span> java.util.List;

<span class="keyword">public</span> class ListTest {

<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) {
    <span class="comment">// TODO Auto-generated method stub</span>

    <span class="comment">//List是一个接口，必须实例化其子类。</span>
    List&lt;<span class="keyword">String</span>&gt; list=<span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;();
    <span class="comment">//集合使用add添加</span>
    list.<span class="built_in">add</span>(<span class="string">"添加字符串"</span>);
    list.<span class="built_in">add</span>(<span class="string">"A"</span>);
    list.<span class="built_in">add</span>(<span class="string">"B"</span>);
    list.<span class="built_in">add</span>(<span class="string">"C"</span>);

    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;list.<span class="built_in">size</span>(); i++) {
        <span class="comment">//集合使用get方法来获取元素内容。</span>
        System.out.<span class="built_in">println</span>(list.<span class="built_in">get</span>(i));
    }
    <span class="comment">//remove删除操作</span>
    list.remove(<span class="number">0</span>);
    System.out.<span class="built_in">println</span>(<span class="string">"删除后的操作"</span>);
    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; list.<span class="built_in">size</span>(); i++) {
        System.out.<span class="built_in">println</span>(list.<span class="built_in">get</span>(i));
    }
    System.out.<span class="built_in">println</span>(<span class="string">"判断集合是否为空"</span>+list.isEmpty());
    <span class="comment">//indexOf返回值是元素的位置。</span>
    System.out.<span class="built_in">println</span>(<span class="string">"判断元素是否存在，例如C: "</span>+list.indexOf(<span class="string">"C"</span>));
}

}
</code></pre><h2 id="Set接口">Set接口</h2><ul>
<li>1.Set接口中不能加入重复元素，但是可以排序</li>
<li>2.常用子类：HashSet 和TreeSet </li>
</ul>
<p>HashSet：无順序性，查找速度快<br>（注意相同多个D，set只会读取一个）<br>TreeSet：有排序性(依字母)，由紅黑樹所建 </p>
<pre><code>import java.util.TreeSet;

public class SetTest {

public static void main(String[] args) {
    // TODO Auto-generated method stub

//        <span class="operator"><span class="keyword">Set</span>&lt;<span class="keyword">String</span>&gt; <span class="keyword">set</span>=new HashSet&lt;<span class="keyword">String</span>&gt;();</span>
    <span class="operator"><span class="keyword">Set</span>&lt;<span class="keyword">String</span>&gt; <span class="keyword">set</span>=new TreeSet&lt;<span class="keyword">String</span>&gt;();</span>
    <span class="operator"><span class="keyword">set</span>.<span class="keyword">add</span>(<span class="string">"2"</span>);</span>
    <span class="operator"><span class="keyword">set</span>.<span class="keyword">add</span>(<span class="string">"4"</span>);</span>
    <span class="operator"><span class="keyword">set</span>.<span class="keyword">add</span>(<span class="string">"1"</span>);</span>
    <span class="operator"><span class="keyword">set</span>.<span class="keyword">add</span>(<span class="string">"31"</span>);</span>
    <span class="operator"><span class="keyword">set</span>.<span class="keyword">add</span>(<span class="string">"a"</span>);</span>
    <span class="operator"><span class="keyword">set</span>.<span class="keyword">add</span>(<span class="string">"D"</span>);</span>
    <span class="operator"><span class="keyword">set</span>.<span class="keyword">add</span>(<span class="string">"D"</span>);</span>

    System.out.println(<span class="operator"><span class="keyword">set</span>);</span>
}

}
</code></pre><h2 id="Iterator接口">Iterator接口</h2><p>1.集合输出的标准操作：标准做法，使用Iterator接口<br>2.操作原理：Iterator是专门的迭代输出接口，迭代输出就是将元素一个个进行判断，判断其是否有内容，如果有内容则把内容取出。</p>
<p>Iterator的实例化比较特别：是通过集合来获得他的一个对象，来实例化。</p>
<p>hasNext()：判断集合中元素是否遍历完毕，如果没有，就返回true<br>next() ：返回下一个元素 </p>
<pre><code>package com.zsz.develop;

<span class="keyword">import</span> java.util.<span class="type">ArrayList</span>;
<span class="keyword">import</span> java.util.<span class="type">Iterator</span>;
<span class="keyword">import</span> java.util.<span class="type">List</span>;

public class <span class="type">IteratorTest</span> {

public <span class="keyword">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args) {
    // <span class="type">TODO</span> <span class="type">Auto</span>-generated <span class="keyword">method</span> stub

    <span class="type">List</span>&lt;<span class="type">Integer</span>&gt; list=new <span class="type">ArrayList</span>&lt;<span class="type">Integer</span>&gt;();
    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {
        list.add(i);

    }
    //使用<span class="type">Iterator</span>标准输出格式来输出
    <span class="type">Iterator</span>&lt;<span class="type">Integer</span>&gt; <span class="keyword">iterator</span>=list.<span class="keyword">iterator</span>();
    <span class="keyword">while</span> (<span class="keyword">iterator</span>.hasNext()) {
        <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="keyword">iterator</span>.next());
    }
}

}
</code></pre><h2 id="Map接口">Map接口</h2><p>1.保存形式：是以Key—value对的方式来保存<br>2.常用子类</p>
<ul>
<li>HashMap：无序存放，KEY不允许重复、</li>
<li>Hashtable：无序存放，KEY不允许重复、</li>
</ul>
<p>在list，set中添加数据都是使用add，而map是使用put添加数据。<br>通过map.get（）可以得到Key中的Value。</p>
<p>要得到所以的键：Map.keySet() 返回类型是set&lt;&gt;;<br>要得到所以的值：Map.Value 返回类型是Collection&lt;&gt;;</p>
<p>map实例</p>
<pre><code>package com.zsz.develop;

<span class="keyword">import</span> java.util.<span class="type">Collection</span>;
<span class="keyword">import</span> java.util.<span class="type">HashMap</span>;
<span class="keyword">import</span> java.util.<span class="type">Iterator</span>;
<span class="keyword">import</span> java.util.<span class="type">Map</span>;
<span class="keyword">import</span> java.util.<span class="type">Set</span>;

public class <span class="type">MapTest</span> {

public <span class="keyword">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args) {
    // <span class="type">TODO</span> <span class="type">Auto</span>-generated <span class="keyword">method</span> stub

    //键值对的形式来存储数据
    <span class="type">Map</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; map=new <span class="type">HashMap</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt;();
    map.put(<span class="string">"key1"</span>, <span class="string">"first"</span>);
    map.put(<span class="string">"key2"</span>, <span class="string">"first2"</span>);
    map.put(<span class="string">"key3"</span>, <span class="string">"first3"</span>);
    map.put(<span class="string">"key4"</span>, <span class="string">"first4"</span>);

    //得到所以的键
    <span class="type">Set</span>&lt;<span class="type">String</span>&gt; <span class="type">set</span>=map.keySet();
    <span class="type">Iterator</span>&lt;<span class="type">String</span>&gt; <span class="keyword">iterator</span>=<span class="type">set</span>.<span class="keyword">iterator</span>();
    <span class="keyword">while</span> (<span class="keyword">iterator</span>.hasNext()) {
        <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="keyword">iterator</span>.next());
    }

    <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"上面为全部键，下面为全部值"</span>);
    //得到所有的值
    <span class="type">Collection</span>&lt;<span class="type">String</span>&gt; collection=map.values();
    <span class="type">Iterator</span>&lt;<span class="type">String</span>&gt; i=collection.<span class="keyword">iterator</span>();
    <span class="keyword">while</span> (i.hasNext()) {
        <span class="type">System</span>.<span class="keyword">out</span>.println(i.next());

    }

    //判断是否存在键
    <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"是否存在键： "</span>+map.containsKey(<span class="string">"key1"</span>));
    //判断是否存在值
    <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"是否存在值： "</span>+map.containsKey(<span class="string">"first1"</span>));

}


}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/06/05/2015-6-5-2/" data-id="cie9kmo3l001d6ob2a0688nkw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


    
      <article id="post-2015-6-5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/04/2015-6-5/">SharedPrefenences的使用</a>
    </h1>
  

        <div class="article-meta">
          <div class="article-date">
  <i class="fa fa-calendar"></i>
  <a href="/2015/06/04/2015-6-5/">
    <time datetime="2015-06-04T13:40:35.000Z" itemprop="datePublished">2015-06-04</time>
  </a>
</div>
          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="SharedPrefenences是什么">SharedPrefenences是什么</h1><p>SharedPrefenences是一种轻型的数据存储方式，他的本质是基于XML文件存储<strong>Ket-Value键值对数据</strong>，通常用来存储一些简单的<strong>配置信息</strong>。</p>
<p>存储位置在/data/data/&lt;包名&gt;/shared_prefs目录下。</p>
<p>SharedPrefenences对象本身只能获取数据而<strong>不支持存储和修改，存储修改要通过Editor对象实现。</strong></p>
<h1 id="SharedPrefenences的优势">SharedPrefenences的优势</h1><p>SharedPrefenences与SQLite数据库相比，免去了创建数据库，创建表，写SQL语句等操作，更加易用。</p>
<p>支持的类型数据</p>
<ul>
<li>boolean</li>
<li>int</li>
<li>float</li>
<li>long</li>
<li>String</li>
</ul>
<p>但是无法进行条件查询。</p>
<h1 id="SharedPrefenences的代码实现">SharedPrefenences的代码实现</h1><p>Activity：</p>
<pre><code><span class="keyword">package</span> com.zsz.develop.sharedpreferencestest;

<span class="keyword">import</span> android.content.SharedPreferences;
<span class="keyword">import</span> android.support.v7.app.ActionBarActivity;
<span class="keyword">import</span> android.os.Bundle;
<span class="keyword">import</span> android.view.Menu;
<span class="keyword">import</span> android.view.MenuItem;
<span class="keyword">import</span> android.view.View;
<span class="keyword">import</span> android.widget.EditText;
<span class="keyword">import</span> android.widget.Toast;


<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">ActionBarActivity</span> </span>{

<span class="keyword">private</span> EditText etData;
<span class="keyword">private</span>  SharedPreferences sharedPreferences;
<span class="annotation">@Override</span>
<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{
    <span class="keyword">super</span>.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    etData= (EditText) findViewById(R.id.etData);
    sharedPreferences=getSharedPreferences(<span class="string">"sharedPrefXML"</span>,MODE_PRIVATE);
    <span class="comment">//要编辑修改sharedPreferences就要使用Editor来修改</span>
   <span class="keyword">final</span> SharedPreferences.Editor editor= sharedPreferences.edit();

    <span class="comment">//读取SharedPreferences数据</span>
    findViewById(R.id.btnRead).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() {
        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>{

            <span class="comment">//得到sharedPreferences的值,传进去第一个参数是键，第二个是如果为空返回的值。</span>
          String value=  sharedPreferences.getString(<span class="string">"key-name"</span>,<span class="string">"当前数值不存在"</span>);
            Toast.makeText(getApplicationContext(),value,Toast.LENGTH_SHORT).show();
        }
    });

    <span class="comment">//写入SharedPreferences数据</span>
    findViewById(R.id.btnWrite).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() {
        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>{

            <span class="comment">//要修改存储什么类型数据就put什么类型,这里传进去的是Key-Value</span>
            editor.putString(<span class="string">"key-name"</span>,etData.getText().toString().trim());
            <span class="comment">//commit提交数据,commit返回值为boolean。进行判断</span>
          <span class="keyword">if</span> (editor.commit()) {
              Toast.makeText(getApplicationContext(), <span class="string">"写入成功"</span>, Toast.LENGTH_SHORT).show();
          }
        }
    });



}



}
</code></pre><p>layout档：</p>
<pre><code>&lt;LinearLayout xmlns:<span class="variable">android=</span><span class="string">"http://schemas.android.com/apk/res/android"</span>
xmlns:<span class="variable">tools=</span><span class="string">"http://schemas.android.com/tools"</span> android:<span class="variable">layout_width=</span><span class="string">"match_parent"</span>
android:<span class="variable">layout_height=</span><span class="string">"match_parent"</span>
android:<span class="variable">orientation=</span><span class="string">"vertical"</span>&gt;
&lt;EditText
   android:<span class="variable">layout_width=</span><span class="string">"fill_parent"</span>
   android:<span class="variable">layout_height=</span><span class="string">"wrap_content"</span>
   android:<span class="variable">id=</span><span class="string">"@+id/etData"</span>
   /&gt;
&lt;Button
    android:<span class="variable">layout_width=</span><span class="string">"fill_parent"</span>
    android:<span class="variable">layout_height=</span><span class="string">"wrap_content"</span>
    android:<span class="variable">id=</span><span class="string">"@+id/btnRead"</span>
    android:<span class="variable">text=</span><span class="string">"读取数据"</span>
    /&gt;

&lt;Button
    android:<span class="variable">layout_width=</span><span class="string">"fill_parent"</span>
    android:<span class="variable">layout_height=</span><span class="string">"wrap_content"</span>
    android:<span class="variable">id=</span><span class="string">"@+id/btnWrite"</span>
    android:<span class="variable">text=</span><span class="string">"写入数据"</span>
    /&gt;
&lt;/LinearLayout&gt;
</code></pre><p>SharedPrefenences非常方便的使用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/06/04/2015-6-5/" data-id="cie9kmo3j001c6ob2arbw2sau" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


    
      <article id="post-2015-6-4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/04/2015-6-4/">清除用户数据</a>
    </h1>
  

        <div class="article-meta">
          <div class="article-date">
  <i class="fa fa-calendar"></i>
  <a href="/2015/06/04/2015-6-4/">
    <time datetime="2015-06-04T08:03:24.000Z" itemprop="datePublished">2015-06-04</time>
  </a>
</div>
          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="清除用户数据">清除用户数据</h1><p>非常实用的清空数据函数。</p>
<p>主要通过deleteFilesByDirectory（）函数删除文件，来达到清楚数据的功能。</p>
<p>功能有清除内/外缓存，清除数据库，清除sharedPreference，清除files和清除自定义目录</p>
<pre><code>package com.fsd.zsz.manplan.main;

/<span class="keyword">*</span><span class="keyword">*</span>
 <span class="keyword">*</span> Created by shengzhong on 2015/6/3.
 <span class="keyword">*</span>/


import java.io.File;
import android.content.Context;
import android.os.Environment;
/<span class="keyword">*</span><span class="keyword">*</span> <span class="keyword">*</span> 本应用数据清除管理器 <span class="keyword">*</span>/
public class DataCleanManager {
    /<span class="keyword">*</span><span class="keyword">*</span> <span class="keyword">*</span> 清除本应用内部缓存(/data/data/com.xxx.xxx/cache) <span class="keyword">*</span> <span class="keyword">*</span> <span class="comment">@param context */</span>
    public static void cleanInternalCache(Context context) {
        deleteFilesByDirectory(context.getCacheDir());
    }
    /<span class="keyword">*</span><span class="keyword">*</span> <span class="keyword">*</span> 清除本应用所有数据库(/data/data/com.xxx.xxx/databases) <span class="keyword">*</span> <span class="keyword">*</span> <span class="comment">@param context */</span>
    public static void cleanDatabases(Context context) {
        deleteFilesByDirectory(new File(<span class="string">"/data/data/"</span>
                + context.getPackageName() + <span class="string">"/databases"</span>));
    }
    /<span class="keyword">*</span><span class="keyword">*</span>
     <span class="keyword">*</span> <span class="keyword">*</span> 清除本应用SharedPreference(/data/data/com.xxx.xxx/shared_prefs) <span class="keyword">*</span> <span class="keyword">*</span> <span class="comment">@param</span>
     <span class="keyword">*</span> context
     <span class="keyword">*</span>/
    public static void cleanSharedPreference(Context context) {
        deleteFilesByDirectory(new File(<span class="string">"/data/data/"</span>
                + context.getPackageName() + <span class="string">"/shared_prefs"</span>));
    }
    /<span class="keyword">*</span><span class="keyword">*</span> <span class="keyword">*</span> 按名字清除本应用数据库 <span class="keyword">*</span> <span class="keyword">*</span> <span class="comment">@param context * @param dbName */</span>
    public static void cleanDatabaseByName(Context context, String dbName) {
        context.deleteDatabase(dbName);
    }
    /<span class="keyword">*</span><span class="keyword">*</span> <span class="keyword">*</span> 清除/data/data/com.xxx.xxx/files下的内容 <span class="keyword">*</span> <span class="keyword">*</span> <span class="comment">@param context */</span>
    public static void cleanFiles(Context context) {
        deleteFilesByDirectory(context.getFilesDir());
    }
    /<span class="keyword">*</span><span class="keyword">*</span>
     <span class="keyword">*</span> <span class="keyword">*</span> 清除外部cache下的内容(/mnt/sdcard/android/data/com.xxx.xxx/cache) <span class="keyword">*</span> <span class="keyword">*</span> <span class="comment">@param</span>
     <span class="keyword">*</span> context
     <span class="keyword">*</span>/
    public static void cleanExternalCache(Context context) {
        if (Environment.getExternalStorageState().equals(
                Environment.MEDIA_MOUNTED)) {
            deleteFilesByDirectory(context.getExternalCacheDir());
        }
    }
    /<span class="keyword">*</span><span class="keyword">*</span> <span class="keyword">*</span> 清除自定义路径下的文件，使用需小心，请不要误删。而且只支持目录下的文件删除 <span class="keyword">*</span> <span class="keyword">*</span> <span class="comment">@param filePath */</span>
    public static void cleanCustomCache(String filePath) {
        deleteFilesByDirectory(new File(filePath));
    }
    /<span class="keyword">*</span><span class="keyword">*</span> <span class="keyword">*</span> 清除本应用所有的数据 <span class="keyword">*</span> <span class="keyword">*</span> <span class="comment">@param context * @param filepath */</span>
    public static void cleanApplicationData(Context context, String... filepath) {
        cleanInternalCache(context);
        cleanExternalCache(context);
        cleanDatabases(context);
        cleanSharedPreference(context);
        cleanFiles(context);
        for (String filePath : filepath) {
            cleanCustomCache(filePath);
        }
    }
    /<span class="keyword">*</span><span class="keyword">*</span> <span class="keyword">*</span> 删除方法 这里只会删除某个文件夹下的文件，如果传入的directory是个文件，将不做处理 <span class="keyword">*</span> <span class="keyword">*</span> <span class="comment">@param directory */</span>
    private static void deleteFilesByDirectory(File directory) {
        if (directory != null &amp;&amp; directory.exists() &amp;&amp; directory.isDirectory()) {
            for (File item : directory.listFiles()) {
                item.delete();
            }
        }
    }
}
</code></pre><p>出处：<a href="http://blog.csdn.net/berber78/article/details/38587567" target="_blank" rel="external">http://blog.csdn.net/berber78/article/details/38587567</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/06/04/2015-6-4/" data-id="cie9kmo3m001e6ob2y3ouqavf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


    
      <article id="post-2015-5-31" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/31/2015-5-31/">Android设置日期与时间</a>
    </h1>
  

        <div class="article-meta">
          <div class="article-date">
  <i class="fa fa-calendar"></i>
  <a href="/2015/05/31/2015-5-31/">
    <time datetime="2015-05-31T11:51:39.000Z" itemprop="datePublished">2015-05-31</time>
  </a>
</div>
          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Android设置日期与时间">Android设置日期与时间</h1><p>取得设置系统时间是Android非常实用的一个功能</p>
<h2 id="取得系统时间">取得系统时间</h2><p>实例化Calendar时，他已经默认的设置了系统时间。<br>setTimeInMillis（）这个方法，会根据你传入的毫秒数对日历对象中的变量进行相应设置。System.currentTimeMillis()可以得到系统到距离1970年1月1日0时的毫秒数</p>
<pre><code>      <span class="comment">//Calendar定义日历对象</span>
<span class="keyword">private</span> Calendar calendar;
    <span class="comment">//实例化日历对象</span>
    calendar=Calendar.getInstance();
    <span class="comment">//设置系统时间</span>
    calendar.setTimeInMillis(System.currentTimeMillis());
    <span class="comment">//得到系统时间</span>
   <span class="keyword">final</span> Date time=calendar.getTime();
    <span class="comment">//得到时和分</span>
   <span class="keyword">final</span> <span class="built_in">int</span> <span class="built_in">hour</span>= calendar.<span class="built_in">get</span>(Calendar.HOUR_OF_DAY);
    <span class="keyword">final</span> <span class="built_in">int</span> <span class="built_in">minute</span>=calendar.<span class="built_in">get</span>(Calendar.MINUTE);
</code></pre><h2 id="时间选择器">时间选择器</h2><p>时间选择器：<br>TimePickerDialog(Contextcontext,TimePickerDialog.OnTimeSetListenercallBack, int hourOfDay, int minute, boolean is24HourView)</p>
<ul>
<li><p>其中TimePickerDialog.OnTimeSetListenercallBack是用户选择好时间后，通知应用的回调函数。监听用户更改时间参数，调用的方法。</p>
</li>
<li><p>is24HourView选择是否为24小时制</p>
</li>
<li></li>
</ul>
<pre><code>tvTime= (TextView) findViewById(R.id.tvTime);
   tvTime.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() {
       <span class="annotation">@Override</span>
       <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>{
           <span class="keyword">new</span> TimePickerDialog(MainActivity.<span class="keyword">this</span>,<span class="keyword">new</span> TimePickerDialog.OnTimeSetListener() {
               <span class="annotation">@Override</span>
               <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onTimeSet</span><span class="params">(TimePicker timePicker, <span class="keyword">int</span> i, <span class="keyword">int</span> i2)</span> </span>{
                   tvTime.setText(<span class="string">"shi"</span>+i+<span class="string">"fen"</span>+i2);
               }
           },<span class="number">10</span>,<span class="number">20</span>,<span class="keyword">true</span>).show();
       }
   });
</code></pre><h2 id="日期选择器">日期选择器</h2><p>同理时间选择器</p>
<pre><code>tvDate= (TextView) findViewById(R.id.tvDate);
   tvDate.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() {
       <span class="annotation">@Override</span>
       <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>{

           <span class="keyword">new</span> DatePickerDialog(MainActivity.<span class="keyword">this</span>, <span class="keyword">new</span> DatePickerDialog.OnDateSetListener() {
               <span class="annotation">@Override</span>
               <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onDateSet</span><span class="params">(DatePicker view, <span class="keyword">int</span> year, <span class="keyword">int</span> monthOfYear, <span class="keyword">int</span> dayOfMonth)</span> </span>{

                   tvDate.setText(String.format(<span class="string">"%d:%d:%d"</span>,year,monthOfYear,dayOfMonth));
               }

           },<span class="number">2015</span>,<span class="number">6</span>,<span class="number">2</span>).show();
       }
   });
</code></pre><p>Layout档</p>
<pre><code>   &lt;TextView
    android:<span class="variable">layout_width=</span><span class="string">"wrap_content"</span>
    android:<span class="variable">layout_height=</span><span class="string">"wrap_content"</span>
    android:<span class="variable">text=</span><span class="string">"0000:00:00"</span>
    android:<span class="variable">id=</span><span class="string">"@+id/tvDate"</span>
    /&gt;

&lt;TextView
    android:<span class="variable">layout_width=</span><span class="string">"wrap_content"</span>
    android:<span class="variable">layout_height=</span><span class="string">"wrap_content"</span>
    android:<span class="variable">text=</span><span class="string">"00:00:00"</span>
    android:<span class="variable">id=</span><span class="string">"@+id/tvTime"</span>
    /&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/05/31/2015-5-31/" data-id="cie9kmo3p001f6ob2mn72vp7j" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


    
      <nav id="page-nav">
        <a class="extend prev" rel="prev" href="/page/4/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/6/">Next &raquo;</a>
      </nav>
    </section>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 zszdevelop<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="http://github.com/ppoffice">PPOffice</a>
    </div>
  </div>
</footer>
    


<script src="//ajax.useso.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>