<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>zszBlog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="this zszdeveloper blog��welcome��">
<meta property="og:type" content="website">
<meta property="og:title" content="zszBlog">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="zszBlog">
<meta property="og:description" content="this zszdeveloper blog��welcome��">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="zszBlog">
<meta name="twitter:description" content="this zszdeveloper blog��welcome��">
  
  
  <link href='//fonts.useso.com/css?family=Open+Sans:400italic,400,600' rel='stylesheet' type='text/css'>
  <link href="//fonts.useso.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css" type="text/css">
  

  
</head>
<body>
  <div id="container">
    <header id="header">
  <div id="header-main" class="header-inner">
    <div class="outer">
      <a href="/" id="logo"><i class="logo"></i><span class="site-title">zszBlog</span></a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/.">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/categories">Categories</a>
        
          <a class="main-nav-link" href="/tags">Tags</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        <div class="profile" id="profile-nav">
          <a id="profile-anchor" href="javascript:;"><img class="avatar" src="http://cl.ly/image/382p262u1E3o/%60IF)_M7]QGJMAK096_$F$$6.png"><i class="fa fa-caret-down"></i></a>
        </div>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"> </button><input type="hidden" name="q" value="site:http://yoursite.com"></form>
      </div>
    </div>
  </div>
  <div id="main-nav-mobile" class="header-sub header-inner">
    <table class="menu outer">
      <tr>
      
        <td><a class="main-nav-link" href="/.">Home</a></td>
      
        <td><a class="main-nav-link" href="/archives">Archives</a></td>
      
        <td><a class="main-nav-link" href="/categories">Categories</a></td>
      
        <td><a class="main-nav-link" href="/tags">Tags</a></td>
      
        <td><a class="main-nav-link" href="/about">About</a></td>
      
      <td>
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="hidden" name="q" value="site:http://yoursite.com"></form>
      </td>
      </tr>
    </table>
  </div>
</header>
    <div class="outer">
      <aside id="profile">
  <div class="inner profile-inner">
  	<div class="base-info profile-block">
		  <img id="avatar" src="http://cl.ly/image/382p262u1E3o/%60IF)_M7]QGJMAK096_$F$$6.png">
      <h2 id="name">zszdevelop</h2>
      <h3 id="title">Java&amp;Android Developer</h3>
      <span id="location"><i class="fa fa-map-marker"></i>XiaMen, China</span>
      <a id="follow" href="undefined">FOLLOW</a>
  	</div>
    <div class="article-info profile-block">
      <div class="article-info-block">
        63
        <span>posts</span>
      </div>
      <div class="article-info-block">
        0
        <span>tag</span>
      </div>
    </div>
    
    <div class="contact-info profile-block">
      <table class="contact-list">
        <tr>
        
          <td><a href="https://github.com/zszdevelop" target="_blank" title="github"><i class="fa fa-github"></i></a></td>
        
          <td><a href="/#" target="_blank" title="twitter"><i class="fa fa-twitter"></i></a></td>
        
          <td><a href="https://www.facebook.com/profile.php?id=100007317255366" target="_blank" title="facebook"><i class="fa fa-facebook"></i></a></td>
        
        </tr>
      </table>
    </div>
    
  </div>
</aside>
      <section id="main">
      <article id="post-2015-7-23-URI-Intent" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/23/2015-7-23-URI-Intent/"> 2015/7/23-URI-Intent</a>
    </h1>
  

        <div class="article-meta">
          <div class="article-date">
  <i class="fa fa-calendar"></i>
  <a href="/2015/07/23/2015-7-23-URI-Intent/">
    <time datetime="2015-07-23T01:05:42.000Z" itemprop="datePublished">2015-07-23</time>
  </a>
</div>
          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="通过URI和Intent启动各种功能">通过URI和Intent启动各种功能</h1><h2 id="Uri">Uri</h2><p>就Android平台而言，URI主要分三个部分：scheme, authority and path。其中authority又分为host和port。格式如下：<br>scheme://host:port/path<br>举个实际的例子：</p>
<p><img src="http://cl.ly/image/2l2F3K3b2W2n/36D61U2UNF%25SOXIFK2%60UN%25N.png" alt=""></p>
<p>现在大家应该知道data flag中那些属性的含义了吧，看下data flag<br><data android:host="string" android:mimetype="string" android:path="string" android:pathpattern="string" android:pathprefix="string" android:port="string" android:scheme="string"></data></p>
<p>但是我们在程序中一般是不直接用URI来标识CP的，是的，正如我们通常见到的用定义的常量来标识。例如standard CP中的Contacts，我们就用Contacts.People.CONTENT_URI来标识Contacts CP中People这个表。那么要标识某个具体的人怎么办呢？ 这就用到了ContentUris.withAppendedId() 和 Uri.withAppendedPath()。例如我们要表示content://contacts/people/20，那么我们就可以用如下语句：<br>Uri uri = ContentUris.withAppendedId(People.CONTENT_URI, 20); 或者<br>Uri uri = Uri.withAppendedPath(People.CONTENT_URI, “20”);</p>
<p>举些例子，如：</p>
<p>所有联系人的Uri： content://contacts/people</p>
<p>某个联系人的Uri: content://contacts/people/5</p>
<p>所有图片Uri: content://media/external</p>
<p>某个图片的Uri：content://media/external/images/media/4</p>
<p>下面是一些常用的Uri</p>
<p><strong>显示网页:</strong></p>
<ol>
<li>Uri uri = Uri.parse(“<a href="http://www.google.com" target="_blank" rel="external">http://www.google.com</a>“);</li>
<li>Intent it = new Intent(Intent.ACTION_VIEW,uri);</li>
<li>startActivity(it);</li>
</ol>
<p><strong>显示地图:</strong></p>
<ol>
<li>Uri uri = Uri.parse(“geo:38.899533,-77.036476”);<ol>
<li>Intent it = new Intent(Intent.Action_VIEW,uri);</li>
<li>startActivity(it);</li>
</ol>
</li>
</ol>
<p><strong>路径规划:</strong></p>
<ol>
<li>Uri uri = Uri.parse(“<a href="http://maps.google.com/maps?f=d&amp;saddr=startLat%20startLng&amp;daddr=endLat%20endLng&amp;hl=en" target="_blank" rel="external">http://maps.google.com/maps?f=d&amp;saddr=startLat%20startLng&amp;daddr=endLat%20endLng&amp;hl=en</a>“);</li>
<li>Intent it = new Intent(Intent.ACTION_VIEW,URI);</li>
<li>startActivity(it);</li>
</ol>
<p><strong>拨打电话:<br>调用拨号程序</strong></p>
<ol>
<li>Uri uri = Uri.parse(“tel:xxxxxx”);</li>
<li>Intent it = new Intent(Intent.ACTION_DIAL, uri);   </li>
<li>startActivity(it);   </li>
<li>Uri uri = Uri.parse(“tel.xxxxxx”);</li>
<li>Intent it =new Intent(Intent.ACTION_CALL,uri);</li>
<li>要使用这个必须在配置文件中加入<uses-permission id="Android.permission.CALL_PHONE"></uses-permission></li>
</ol>
<p><strong>发送SMS/MMS<br>调用发送短信的程序</strong></p>
<ol>
<li>Intent it = new Intent(Intent.ACTION_VIEW);</li>
<li>it.putExtra(“sms_body”, “The SMS text”);</li>
<li>it.setType(“vnd.android-dir/mms-sms”);</li>
<li>startActivity(it);   </li>
</ol>
<p><strong>发送短信</strong></p>
<ol>
<li>Uri uri = Uri.parse(“smsto:0800000123”);</li>
<li>Intent it = new Intent(Intent.ACTION_SENDTO, uri);</li>
<li>it.putExtra(“sms_body”, “The SMS text”);</li>
<li>startActivity(it);   </li>
</ol>
<p><strong>发送彩信</strong></p>
<ol>
<li>Uri uri = Uri.parse(“content://media/external/images/media/23”);</li>
<li>Intent it = new Intent(Intent.ACTION_SEND);</li>
<li>it.putExtra(“sms_body”, “some text”);</li>
<li>it.putExtra(Intent.EXTRA_STREAM, uri);</li>
<li>it.setType(“image/png”);</li>
<li>startActivity(it);</li>
</ol>
<p><strong><br>发送Email</strong></p>
<p>  1.</p>
<ol>
<li>Uri uri = Uri.parse(“mailto:xxx@abc.com”);</li>
<li>Intent it = new Intent(Intent.ACTION_SENDTO, uri);</li>
<li>startActivity(it);</li>
<li>Intent it = new Intent(Intent.ACTION_SEND);</li>
<li>it.putExtra(Intent.EXTRA_EMAIL, “me@abc.com”);</li>
<li>it.putExtra(Intent.EXTRA_TEXT, “The email body text”);</li>
<li>it.setType(“text/plain”);</li>
<li>startActivity(Intent.createChooser(it, “Choose Email Client”));   </li>
<li>Intent it=new Intent(Intent.ACTION_SEND);   </li>
<li>String[] tos={“me@abc.com”};   </li>
<li>String[] ccs={“you@abc.com”};   </li>
<li>it.putExtra(Intent.EXTRA_EMAIL, tos);   </li>
<li>it.putExtra(Intent.EXTRA_CC, ccs);   </li>
<li>it.putExtra(Intent.EXTRA_TEXT, “The email body text”);   </li>
<li>it.putExtra(Intent.EXTRA_SUBJECT, “The email subject text”);   </li>
<li>it.setType(“message/rfc822”);   </li>
<li>startActivity(Intent.createChooser(it, “Choose Email Client”));</li>
</ol>
<p><strong>添加附件</strong></p>
<ol>
<li>Intent it = new Intent(Intent.ACTION_SEND);</li>
<li>it.putExtra(Intent.EXTRA_SUBJECT, “The email subject text”);</li>
<li>it.putExtra(Intent.EXTRA_STREAM, “[url=]file:///sdcard/mysong.mp3[/url]”);</li>
<li>sendIntent.setType(“audio/mp3”);</li>
<li>startActivity(Intent.createChooser(it, “Choose Email Client”));</li>
</ol>
<p><strong>播放多媒体</strong></p>
<ol>
<li></li>
<li>Intent it = new Intent(Intent.ACTION_VIEW);</li>
<li>Uri uri = Uri.parse(“[url=]file:///sdcard/song.mp3[/url]”);</li>
<li>it.setDataAndType(uri, “audio/mp3”);</li>
<li>startActivity(it);</li>
<li>Uri uri = Uri.withAppendedPath(MediaStore.Audio.Media.INTERNAL_CONTENT_URI, “1”);</li>
<li>Intent it = new Intent(Intent.ACTION_VIEW, uri);</li>
<li>startActivity(it);   </li>
</ol>
<p><strong>Uninstall 程序</strong></p>
<ol>
<li>Uri uri = Uri.fromParts(“package”, strPackageName, null);</li>
<li>Intent it = new Intent(Intent.ACTION_DELETE, uri);</li>
<li>startActivity(it);</li>
</ol>
<p><strong>//调用相册</strong></p>
<p>public static final String MIME_TYPE_IMAGE_JPEG = “image/*”;<br>public static final int ACTIVITY_GET_IMAGE = 0;<br>Intent getImage = new Intent(Intent.ACTION_GET_CONTENT);<br>getImage.addCategory(Intent.CATEGORY_OPENABLE);<br>getImage.setType(MIME_TYPE_IMAGE_JPEG);<br>startActivityForResult(getImage, ACTIVITY_GET_IMAGE);</p>
<p><strong>//调用系统相机应用程序，并存储拍下来的照片</strong></p>
<p>Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);<br>time = Calendar.getInstance().getTimeInMillis();<br>intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(new File(Environment<br>.getExternalStorageDirectory().getAbsolutePath()+”/tucue”, time + “.jpg”)));<br>startActivityForResult(intent, ACTIVITY_GET_CAMERA_IMAGE);</p>
<p>uninstall apk</p>
<p><strong>未测试</strong></p>
<p>Uri uninstallUri = Uri.fromParts(“package”, “xxx”, null);<br>returnIt = new Intent(Intent.ACTION_DELETE, uninstallUri);<br>*/<br>Uri packageURI = Uri.parse(“package:”+wistatmap);<br>Intent uninstallIntent = new Intent(Intent.ACTION_DELETE, packageURI);<br>startActivity(uninstallIntent);</p>
<p>install apk<br>Uri installUri = Uri.fromParts(“package”, “xxx”, null);<br>returnIt = new Intent(Intent.ACTION_PACKAGE_ADDED, installUri);<br>play audio<br>Uri playUri = Uri.parse(“[url=]file:///sdcard/download/everything.mp3[/url]”);<br>returnIt = new Intent(Intent.ACTION_VIEW, playUri);</p>
<p><strong>//发送附件</strong></p>
<p>Intent it = new Intent(Intent.ACTION_SEND);<br>it.putExtra(Intent.EXTRA_SUBJECT, “The email subject text”);<br>it.putExtra(Intent.EXTRA_STREAM, “[url=]file:///sdcard/eoe.mp3[/url]”);<br>sendIntent.setType(“audio/mp3”);<br>startActivity(Intent.createChooser(it, “Choose Email Client”));</p>
<p><strong>//搜索应用</strong></p>
<p>Uri uri = Uri.parse(“market://search?q=pname:pkg_name”);<br>Intent it = new Intent(Intent.ACTION_VIEW, uri);<br>startActivity(it);<br>//where pkg_name is the full package path for an application</p>
<p><strong>进入联系人页面</strong></p>
<p>Intent intent = new Intent();<br>intent.setAction(Intent.ACTION_VIEW);<br>intent.setData(People.CONTENT_URI);<br>startActivity(intent);</p>
<p><strong>查看指定联系人</strong></p>
<p>Uri personUri = ContentUris.withAppendedId(People.CONTENT_URI, info.id);//info.id联系人ID<br>Intent intent = new Intent();<br>intent.setAction(Intent.ACTION_VIEW);<br>intent.setData(personUri);<br>startActivity(intent);</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/07/23/2015-7-23-URI-Intent/" data-id="cieb6up620017tob2d2jmjb5c" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


    
      <article id="post-2015-7-23" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/23/2015-7-23/"> 注销，TaskStack，affinity</a>
    </h1>
  

        <div class="article-meta">
          <div class="article-date">
  <i class="fa fa-calendar"></i>
  <a href="/2015/07/23/2015-7-23/">
    <time datetime="2015-07-23T01:05:22.000Z" itemprop="datePublished">2015-07-23</time>
  </a>
</div>
          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="7-23日问题集">7.23日问题集</h1><h2 id="Android注销流程">Android注销流程</h2><p>当我们点击注销按钮之后，一般都会重新返回登陆界面，这时候我们再按返回键是没有用的。这时候其实我们是将Android 的TaskStack清空。</p>
<p>这里要设置Intent的FLAG,在执行完成Activity跳转的时候会清空TaskStack，并且将创建一个新的TaskStack</p>
<p>注销</p>
<pre><code><span class="type">Intent</span> logoutIntent = new <span class="type">Intent</span>(ctx, LoginActivity.<span class="keyword">class</span>);
                logoutIntent.setFlags(<span class="type">Intent</span>.FLAG_ACTIVITY_CLEAR_TASK | <span class="type">Intent</span>.FLAG_ACTIVITY_NEW_TASK);
                startActivity(logoutIntent);
</code></pre><h2 id="什么是Activity_Stack？">什么是Activity Stack？</h2><p>　　Activity承担了大量的显示和交互工作，从某种角度上将，我们看见的应用程序就是许多个Activity的组合。为了让这许多 Activity协同工作而不至于产生混乱，Android平台设计了一种堆栈机制用于管理Activity，其遵循先进后出的原则，系统总是显示位于栈 顶的Activity，从逻辑上将，位于栈顶的Activity也就是最后打开的Activity，这也是符合逻辑的。</p>
<p>　　在操作应用程序时，每次启动新的Activity，都会将此压入Activity Stack，当用户执行返回操作时，移除Activity Stack顶上的Activity，这样就实现了返回上一个Activty的功能。直到用户一直返回到Home Screen，这时候可以理解为移除了Activity Stack所有的Activity，这个Activity Stack不再存在，应用程序也结束了运行。</p>
<h2 id="什么是Task？">什么是Task？</h2><p>　　Task是指将相关的Activity组合到一起，以Activity Stack的方式进行管理。从用户体验上讲，一个“应用程序”就是一个Task，但是从根本上讲，一个Task是可以有一个或多个Android Application组成的。例如：你想在发送短信时，拍一张照并作为彩信发出去，这时你首先停留在短信应用程序的的Acitivity上，然后跳转到 Camera应用程序的Activity上，当完成拍照功能后，再返回到短信应用程序的Activity。这实际上是两个Android Application协同合作后完成的工作，但为了更好的用户体验，Android平台加入了Task这么一种机制，让用户没有感觉到应用的中断，让用 户感觉在一“应用程序”里就完成了想完成的工作。</p>
<h2 id="Activity的affinity(亲和力)">Activity的affinity(亲和力)</h2><p>task对于Activity来说就好像它的身份证一样，可以告诉所在的task，自己属于这个task中的一员；拥有相同affinity的多个Activity理论同属于一个task，task自身的affinity决定于根Activity的affinity值。affinity在什么场合应用呢？1.根据affinity重新为Activity选择宿主task（与allowTaskReparenting属性配合工作）；2.启动一个Activity过程中Intent使用了FLAG_ACTIVITY_NEW_TASK标记，根据affinity查找或创建一个新的具有对应affinity的task。我们会在后面进行详细讲解。</p>
<p>默认情况下，一个应用内的所有Activity都具有相同的affinity，都是从Application（参考<application>的taskAffinity属性）继承而来，而Application默认的affinity是<manifest>中的包名，我们可以为<application>设置taskAffinity属性值，这样可以应用到<application>下的所有<activity>，也可以单独为某个Activity设置taskAffinity。</activity></application></application></manifest></application></p>
<h2 id="Intent几种常见的flags：">Intent几种常见的flags：</h2><h3 id="FLAG_ACTIVITY_CLEAR_TASK">FLAG_ACTIVITY_CLEAR_TASK</h3><p><strong>FLAG_ACTIVITY_CLEAR_TASK </strong>:如果在调用Context.startActivity时传递这个标记，将会导致任何用来放置该activity的已经存在的task里面的已经存在的activity先清空，然后该activity再在该task中启动，也就是说，这个新启动的activity变为了这个空tas的根activity.所有老的activity都结束掉。该标志必须和FLAG_ACTIVITY_NEW_TASK一起使用。</p>
<h3 id="-FLAG_ACTIVITY_CLEAR_TOP">.FLAG_ACTIVITY_CLEAR_TOP</h3><p>当Intent对象包含这个标记时，如果在栈中发现存在Activity实例，则清空这个实例之上的Activity，使其处于栈顶。例如：我们的FirstActivity跳转到SecondActivity，SecondActivity跳转到ThirdActivity，而ThirdActivity又跳到SecondActivity，那么ThirdActivity实例将被弹出栈，使SecondActivity处于栈顶，显示到幕前，栈内只剩下FirstActivity和SecondActivity。这个SecondActivity既可以在onNewIntent()中接收到传来的Intent，也可以把自己销毁之后重新启动来接受这个Intent。在使用默认的“standard”启动模式下，如果没有在Intent使用到FLAG_ACTIVITY_SINGLE_TOP标记，那么它将关闭后重建，如果使用了这个FLAG_ACTIVITY_SINGLE_TOP标记，则会使用已存在的实例；对于其他启动模式，无需再使用FLAG_ACTIVITY_SINGLE_TOP，它都将使用已存在的实例，Intent会被传递到这个实例的onNewIntent()中。</p>
<h3 id="FLAG_ACTIVITY_SINGLE_TOP">FLAG_ACTIVITY_SINGLE_TOP</h3><p>当task中存在目标Activity实例并且位于栈的顶端时，不再创建一个新的，直接利用这个实例。我们在上边的例子中也有讲到。</p>
<h3 id="FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET">FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET</h3><p>如果一个Intent中包含此属性，则它转向的那个Activity以及在那个Activity其上的所有Activity都会在task重置时被清除出task。当我们将一个后台的task重新回到前台时，系统会在特定情况下为这个动作附带一个FLAG_ACTIVITY_RESET_TASK_IF_NEEDED标记，意味着必要时重置task，这时FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET就会生效。经过测试发现，对于一个处于后台的应用，如果在主选单点击应用，这个动作中含有FLAG_ACTIVITY_RESET_TASK_IF_NEEDED标记，长按Home键，然后点击最近记录，这个动作不含FLAG_ACTIVITY_RESET_TASK_IF_NEEDED标记,所以前者会清除，后者不会</p>
<h3 id="FLAG_ACTIVITY_RESET_TASK_IF_NEEDED">FLAG_ACTIVITY_RESET_TASK_IF_NEEDED</h3><p>这个标记在以下情况下会生效：1.启动Activity时创建新的task来放置Activity实例；2.已存在的task被放置于前台。系统会根据affinity对指定的task进行重置操作，task会压入某些Activity实例或移除某些Activity实例。我们结合上面的CLEAR_WHEN_TASK_RESET可以加深理解。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/07/23/2015-7-23/" data-id="cieb6up5z0016tob28aktq186" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


    
      <article id="post-2015-7-22" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/22/2015-7-22/">putExtra()，Intent的构造函数，startActivityForResult的用法，onActivityResult</a>
    </h1>
  

        <div class="article-meta">
          <div class="article-date">
  <i class="fa fa-calendar"></i>
  <a href="/2015/07/22/2015-7-22/">
    <time datetime="2015-07-22T11:30:13.000Z" itemprop="datePublished">2015-07-22</time>
  </a>
</div>
          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="2015/7/22问题集">2015/7/22问题集</h1><h2 id="intent-putExtra()传值">intent.putExtra()传值</h2><p>putExtra(“A”,B)中，AB为键值对，第一个参数为键名，第二个参数为键对应的值。顺便提一下，如果想取出Intent对象中的这些值，需要在你的另一个Activity中用getXXXXXExtra方法，注意需要使用对应类型的方法，参数为键名</p>
<p>第一个Activity，通过intent.putExtra(“key”,”value”);传给另一个Activity</p>
<pre><code>btnIntent.setOnClickListener(<span class="keyword">new</span> OnClickListener() {
       <span class="annotation">@Override</span>
       <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>{
           Intent intent=<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>,ToIntentActicity.class);
           <span class="comment">//将要传递的值附加到Intent对象</span>
           intent.putExtra(<span class="string">"Main"</span>,<span class="string">"66666"</span>);
           startActivity(intent);
       }
   });
</code></pre><p>另一个页面接收数据</p>
<pre><code>tv= (TextView) findViewById(R.id.tv);
  <span class="comment">//取得启动该Activity的Intent对象</span>
  Intent intent=getIntent();
   <span class="comment">/*取出Intent中附加的数据*/</span>
  <span class="keyword">String</span> <span class="built_in">str</span>=intent.getStringExtra(<span class="string">"Main"</span>);
  tv.setText(<span class="string">"从其他Intent传过来的值"</span>+<span class="built_in">str</span>);
</code></pre><hr>
<h2 id="Intent-putExtra()传递Object对象或者ArrayList">Intent.putExtra()传递Object对象或者ArrayList<object></object></h2><p>Intent传递基本类型相信大家都十分熟悉，如何传递Object对象或者ArrayList<object>对象呢？</object></p>
<p>可以通过：</p>
<p>（1）public Intent putExtra (String name, Serializable value)</p>
<p>（2）public Intent putExtra (String name, Parcelable value)</p>
<pre><code><span class="keyword">public</span> <span class="type">Intent</span> putParcelableArrayListExtra(String <span class="keyword">name</span>, ArrayList&lt;? <span class="keyword">extends</span> Parcelable&gt; <span class="keyword">value</span>)
</code></pre><p><strong>一、通过实现Serializable接口传递</strong></p>
<p>实体类继承Serializable。然后</p>
<p>通过Intent来进行传输，具体方法是：public Intent putExtra (String name, Serializable value)</p>
<pre><code><span class="type">Intent</span> <span class="type">ToManChartIntent</span>=<span class="keyword">new</span> <span class="type">Intent</span><span class="literal">()</span>;

         <span class="type">ToManChartIntent</span>.putExtra(<span class="string">"toManChartIntent"</span>,mans);
         getContext<span class="literal">()</span>.startActivity(<span class="type">ToManChartIntent</span>);
</code></pre><p><strong>二、通过实现Parcelable接口传递</strong></p>
<p>同上，Person类实现Parcelable接口即可：</p>
<p>传递Object用：public Intent putExtra (String name, Parcelable value)<br>传递ArrayList<object>用：public Intent putParcelableArrayListExtra(String name, ArrayList&lt;? extends Parcelable&gt; value)</object></p>
<h2 id="Intent的构造函数">Intent的构造函数</h2><p>公共构造函数：</p>
<ul>
<li><p>1、Intent() 空构造函数</p>
</li>
<li><p>2、Intent(Intent o) 拷贝构造函数</p>
</li>
<li><p>3、Intent(String action) 指定action类型的构造函数</p>
</li>
<li><p>4、Intent(String action, Uri uri) 指定Action类型和Uri的构造函数，URI主要是结合程序之间的数据共享ContentProvider</p>
</li>
<li><p>5、Intent(Context packageContext, Class&lt;?&gt; cls) 传入组件的构造函数，也就是上文提到的</p>
</li>
<li><p>6、Intent(String action, Uri uri, Context packageContext, Class&lt;?&gt; cls) 前两种结合体</p>
</li>
</ul>
<p>Intent有六种构造函数，3、4、5是最常用的，并不是其他没用！</p>
<h2 id="startActivityForResult的用法：">startActivityForResult的用法：</h2><ul>
<li><p>1、startActivity( )<br>仅仅是跳转到目标页面，若是想跳回当前页面，则必须再使用一次startActivity( )。</p>
</li>
<li><p>2、startActivityForResult( )<br>可以一次性完成这项任务，当程序执行到这段代码的时候，假若从T1Activity跳转到下一个Text2Activity，而当这个Text2Activity调用了finish()方法以后，程序会自动跳转回T1Activity，并调用前一个T1Activity中的onActivityResult( )方法。</p>
</li>
</ul>
<p>如果想在Activity中得到新打开Activity 关闭后返回的数据，需要使用系统提供的startActivityForResult(Intent intent, int requestCode)方法打开新的Activity，新的Activity 关闭后会向前面的Activity传回数据，为了得到传回的数据，必须在前面的Activity中重写onActivityResult(int requestCode, int resultCode, Intent data)方法。</p>
<pre><code><span class="comment">//这里采用startActivityForResult来做跳转，此处的0为一个依据，可以写其他的值，但一定要&gt;=0</span>

startActivityForResult<span class="comment">(intent, 0)</span>;
</code></pre><h2 id="onActivityResult传值的使用">onActivityResult传值的使用</h2><p>多个activity之间的传值 其实就是onActivityResult，然后别忘了还有一个action的问题 就是在主xml中添加自己的action以便于识别，最后次activity别忘了finansh。</p>
<h2 id="针对startActivityForResult实例代码">针对startActivityForResult实例代码</h2><pre><code><span class="keyword">package</span> com.ljq.activitys;

<span class="keyword">import</span> android.app.Activity;
<span class="keyword">import</span> android.content.Intent;
<span class="keyword">import</span> android.os.Bundle;
<span class="keyword">import</span> android.util.Log;
<span class="keyword">import</span> android.view.View;
<span class="keyword">import</span> android.widget.Button;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>{
<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String TAG=<span class="string">"MainActivity"</span>;

<span class="annotation">@Override</span>
<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{
    <span class="keyword">super</span>.onCreate(savedInstanceState);
    setContentView(R.layout.main);

    Button btnOpen=(Button)<span class="keyword">this</span>.findViewById(R.id.btnOpen);
    btnOpen.setOnClickListener(<span class="keyword">new</span> View.OnClickListener(){
        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>{
            <span class="comment">//得到新打开Activity关闭后返回的数据</span>
            <span class="comment">//第二个参数为请求码，可以根据业务需求自己编号</span>
            startActivityForResult(<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, OtherActivity.class), <span class="number">1</span>);
        }
    });
}

<span class="javadoc">/**
 * 为了得到传回的数据，必须在前面的Activity中（指MainActivity类）重写onActivityResult方法
 * 
 * requestCode 请求码，即调用startActivityForResult()传递过去的值
 * resultCode 结果码，结果码用于标识返回数据来自哪个新Activity
 */</span>
<span class="annotation">@Override</span>
<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>{
    String result = data.getExtras().getString(<span class="string">"result"</span>);<span class="comment">//得到新Activity 关闭后返回的数据</span>
    Log.i(TAG, result);
}
}
</code></pre><p>当新Activity关闭后，新Activity返回的数据通过Intent进行传递，android平台会调用前面Activity 的onActivityResult()方法，把存放了返回数据的Intent作为第三个输入参数传入，在onActivityResult()方法中使用第三个输入参数可以取出新Activity返回的数据。</p>
<h3 id="二、使用startActivityForResult(Intent_intent,_int_requestCode)方法打开新的Activity，新Activity关闭前需要向前面的Activity返回数据需要使用系统提供的setResult(int_resultCode,_Intent_data)方法实现：">二、使用startActivityForResult(Intent intent, int requestCode)方法打开新的Activity，新Activity关闭前需要向前面的Activity返回数据需要使用系统提供的setResult(int resultCode, Intent data)方法实现：</h3><pre><code><span class="keyword">package</span> com.ljq.activitys;

<span class="keyword">import</span> android.app.<span class="type">Activity</span>;
<span class="keyword">import</span> android.content.<span class="type">Intent</span>;
<span class="keyword">import</span> android.os.<span class="type">Bundle</span>;
<span class="keyword">import</span> android.view.<span class="type">View</span>;
<span class="keyword">import</span> android.widget.<span class="type">Button</span>;

public <span class="class"><span class="keyword">class</span> <span class="title">OtherActivity</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Activity</span> {</span>

<span class="annotation">@Override</span>
<span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) {
    <span class="keyword">super</span>.onCreate(savedInstanceState);
    setContentView(<span class="type">R</span>.layout.other);

    <span class="type">Button</span> btnClose=(<span class="type">Button</span>)findViewById(<span class="type">R</span>.id.btnClose);
    btnClose.setOnClickListener(<span class="keyword">new</span> <span class="type">View</span>.<span class="type">OnClickListener</span>(){
        public void onClick(<span class="type">View</span> v) {
            <span class="comment">//数据是使用Intent返回</span>
            <span class="type">Intent</span> intent = <span class="keyword">new</span> <span class="type">Intent</span>();
            <span class="comment">//把返回数据存入Intent</span>
            intent.putExtra(<span class="string">"result"</span>, <span class="string">"My name is linjiqin"</span>);
            <span class="comment">//设置返回数据</span>
            <span class="type">OtherActivity</span>.<span class="keyword">this</span>.setResult(<span class="type">RESULT_OK</span>, intent);
            <span class="comment">//关闭Activity</span>
            <span class="type">OtherActivity</span>.<span class="keyword">this</span>.finish();
        }
    });

}

}
</code></pre><p>setResult()方法的第一个参数值可以根据业务需要自己定义，上面代码中使用到的RESULT_OK是系统Activity类定义的一个常量，值为-1，代码片断如下：<br>public class android.app.Activity extends ……{<br>  public static final int RESULT_CANCELED = 0;<br>  public static final int RESULT_OK = -1;<br>  public static final int RESULT_FIRST_USER = 1;<br>}</p>
<h3 id="请求码的作用">请求码的作用</h3><p>使用startActivityForResult(Intent intent, int requestCode)方法打开新的Activity，我们需要为startActivityForResult()方法传入一个请求码(第二个参数)。请求码的值是根据业务需要由自已设定，用于标识请求来源。例如：一个Activity有两个按钮，点击这两个按钮都会打开同一个Activity，不管是那个按钮打开新Activity，当这个新Activity关闭后，系统都会调用前面Activity的onActivityResult(int requestCode, int resultCode, Intent data)方法。在onActivityResult()方法如果需要知道新Activity是由那个按钮打开的，并且要做出相应的业务处理，这时可以这样做：</p>
<pre><code> @<span class="function">Override  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{
        ....
    button1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener(){
        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>{
            startActivityForResult (<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, NewActivity.<span class="keyword">class</span>), <span class="number">1</span>);

       }

    });
    button2.setOnClickListener(<span class="keyword">new</span> View.OnClickListener(){
        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>{
             startActivityForResult (<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, NewActivity.<span class="keyword">class</span>), <span class="number">2</span>);

        }

    });


   @<span class="function">Override <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>{
           <span class="keyword">switch</span>(requestCode){
               <span class="keyword">case</span> <span class="number">1</span>:
               <span class="comment">//来自按钮1的请求，作相应业务处理</span>
               <span class="keyword">case</span> <span class="number">2</span>:
               <span class="comment">//来自按钮2的请求，作相应业务处理</span>
            }
      }
}
</code></pre><h3 id="结果码的作用">结果码的作用</h3><p>在一个Activity中，可能会使用startActivityForResult()方法打开多个不同的Activity处理不同的业务，当这些新Activity关闭后，系统都会调用前面Activity的onActivityResult(int requestCode, int resultCode, Intent data)方法。为了知道返回的数据来自于哪个新Activity，在onActivityResult()方法中可以这样做(ResultActivity和NewActivity为要打开的新Activity)：<br>public class ResultActivity extends Activity {<br>       …..<br>       ResultActivity.this.setResult(1, intent);<br>       ResultActivity.this.finish();<br>}<br>public class NewActivity extends Activity {<br>       ……<br>        NewActivity.this.setResult(2, intent);<br>        NewActivity.this.finish();<br>}<br>public class MainActivity extends Activity { // 在该Activity会打开ResultActivity和NewActivity<br>       @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) {<br>               switch(resultCode){<br>                   case 1:<br>                   // ResultActivity的返回数据<br>                   case 2:<br>                    // NewActivity的返回数据<br>                }<br>          }<br>} </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/07/22/2015-7-22/" data-id="cieb6up650018tob2bf7j0gix" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


    
      <article id="post-2015-7-21" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/21/2015-7-21/">URIs, URLs, and URNs之间的关系区别，Android拍照功能</a>
    </h1>
  

        <div class="article-meta">
          <div class="article-date">
  <i class="fa fa-calendar"></i>
  <a href="/2015/07/21/2015-7-21/">
    <time datetime="2015-07-21T00:48:01.000Z" itemprop="datePublished">2015-07-21</time>
  </a>
</div>
          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="2015/7/21问题集">2015/7/21问题集</h1><h2 id="URIs,_URLs,_and_URNs之间的关系区别">URIs, URLs, and URNs之间的关系区别</h2><ul>
<li>URI：是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。</li>
<li>URL：是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。</li>
<li>URN：uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。</li>
</ul>
<p>也就是说，URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。</p>
<h2 id="Android拍照功能">Android拍照功能</h2><pre><code>package com.zsz.develop.picturedemo;

    <span class="keyword">import</span> java.io.BufferedOutputStream;
    <span class="keyword">import</span> java.io.File;
    <span class="keyword">import</span> java.io.FileNotFoundException;
    <span class="keyword">import</span> java.io.FileOutputStream;
    <span class="keyword">import</span> java.io.IOException;
    <span class="keyword">import</span> java.util.Calendar;
    <span class="keyword">import</span> java.util.Locale;

    <span class="keyword">import</span> android.app.Activity;
    <span class="keyword">import</span> android.content.Intent;
    <span class="keyword">import</span> android.graphics.Bitmap;
    <span class="keyword">import</span> android.os.Bundle;
    <span class="keyword">import</span> android.os.Environment;
    <span class="keyword">import</span> android.provider.MediaStore;
    <span class="keyword">import</span> android.text.format.DateFormat;
    <span class="keyword">import</span> android.util.Log;
    <span class="keyword">import</span> android.view.View;
    <span class="keyword">import</span> android.view.View.OnClickListener;
    <span class="keyword">import</span> android.widget.Button;
    <span class="keyword">import</span> android.widget.ImageView;
    <span class="keyword">import</span> android.widget.Toast;

public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>{
<span class="comment">/** Called when the activity is first created. */</span>
private Button button;

@Override
public <span class="keyword">void</span> onCreate(Bundle savedInstanceState) {
    <span class="keyword">super</span>.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    button = (Button) findViewById(R.id.btnPicture);
    button.setOnClickListener(<span class="keyword">new</span> OnClickListener() {

        @Override
        public <span class="keyword">void</span> onClick(View v) {
            <span class="comment">// TODO Auto-generated method stub</span>
            Intent intent = <span class="keyword">new</span> Intent(MediaStore.ACTION_IMAGE_CAPTURE);

            startActivityForResult(intent, <span class="number">1</span>);
        }
    });
}

@Override
protected <span class="keyword">void</span> onActivityResult(int requestCode, int resultCode, Intent data) {
    <span class="comment">// TODO Auto-generated method stub</span>
    <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);
    <span class="keyword">if</span> (resultCode == Activity.RESULT_OK) {
        <span class="built_in">String</span> sdStatus = Environment.getExternalStorageState();
        <span class="keyword">if</span> (!sdStatus.equals(Environment.MEDIA_MOUNTED)) { <span class="comment">// 检测sd是否可用</span>
            Log.i(<span class="string">"TestFile"</span>,
                    <span class="string">"SD card is not avaiable/writeable right now."</span>);
            <span class="keyword">return</span>;
        }
        <span class="built_in">String</span> name = <span class="keyword">new</span> DateFormat().format(<span class="string">"yyyyMMdd_hhmmss"</span>,Calendar.getInstance(Locale.CHINA)) + <span class="string">".jpg"</span>;
        Toast.makeText(<span class="keyword">this</span>, name, Toast.LENGTH_LONG).show();
        Bundle bundle = data.getExtras();
        Bitmap bitmap = (Bitmap) bundle.get(<span class="string">"data"</span>);<span class="comment">// 获取相机返回的数据，并转换为Bitmap图片格式</span>

        FileOutputStream b = <span class="literal">null</span>;
        <span class="comment">//???????????????????????????????为什么不能直接保存在系统相册位置呢？？？？？？？？？？？？</span>
        File file = <span class="keyword">new</span> File(<span class="string">"/sdcard/myImage/"</span>);
        file.mkdirs();<span class="comment">// 创建文件夹</span>
        <span class="built_in">String</span> fileName = <span class="string">"/sdcard/myImage/"</span>+name;

        <span class="keyword">try</span> {
            b = <span class="keyword">new</span> FileOutputStream(fileName);
            bitmap.compress(Bitmap.CompressFormat.JPEG, <span class="number">100</span>, b);<span class="comment">// 把数据写入文件</span>
        } <span class="keyword">catch</span> (FileNotFoundException e) {
            e.printStackTrace();
        } <span class="keyword">finally</span> {
            <span class="keyword">try</span> {
                b.flush();
                b.close();
            } <span class="keyword">catch</span> (IOException e) {
                e.printStackTrace();
            }
        }
        ((ImageView) findViewById(R.id.imageView)).setImageBitmap(bitmap);<span class="comment">// 将图片显示在ImageView里</span>
    }
}
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/07/21/2015-7-21/" data-id="cieb6up680019tob2wmowf3au" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


    
      <article id="post-2015-7-20" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/20/2015-7-20/">字节流如何转换为字符流，去除文件中的空格和回车，LayoutInflater加载布局，新建http连接</a>
    </h1>
  

        <div class="article-meta">
          <div class="article-date">
  <i class="fa fa-calendar"></i>
  <a href="/2015/07/20/2015-7-20/">
    <time datetime="2015-07-20T01:51:03.000Z" itemprop="datePublished">2015-07-20</time>
  </a>
</div>
          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="2015/7/20_问题集">2015/7/20 问题集</h1><h2 id="字节流如何转换为字符流">字节流如何转换为字符流</h2><pre><code>FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"c:/abc.txt"</span>);<span class="comment">// 字节流</span>
 InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(fis);<span class="comment">// 字符流</span>
 <span class="keyword">BufferedReader</span> br = <span class="keyword">new</span> <span class="keyword">BufferedReader</span>(isr);<span class="comment">// 缓冲流</span>
 <span class="keyword">String</span> <span class="built_in">str</span> = <span class="keyword">null</span>;
 <span class="keyword">if</span> ((<span class="built_in">str</span> = br.readLine()) != <span class="keyword">null</span>) {
  System.out.<span class="built_in">println</span>(<span class="built_in">str</span>);
 }
 br.close();
 isr.close();
 fis.close();
}
</code></pre><h2 id="去除文件中的空格和回车">去除文件中的空格和回车</h2><pre><code>  content_str=etSend.getText().<span class="keyword">toString</span>();
<span class="comment">//去除空格</span>
    String <span class="keyword">drop</span>=content_str.<span class="keyword">replace</span>(<span class="string">" "</span>,<span class="string">""</span>);
<span class="comment">//    去除回车</span>
    String droph=<span class="keyword">drop</span>.<span class="keyword">replace</span>(<span class="string">"\n"</span>,<span class="string">""</span>);
</code></pre><h2 id="LayoutInflater加载布局">LayoutInflater加载布局</h2><p>findViewById加载控件，LayoutInflater加载布局</p>
<pre><code>LayoutInflater <span class="variable">layoutInflater=</span>LayoutInflater.from(context);

     <span class="variable">layout=</span> (RelativeLayout) layoutInflater.inflate(R.layout.left_item,<span class="constant">null</span>);
</code></pre><h2 id="新建http连接">新建http连接</h2><pre><code><span class="keyword">protected</span> <span class="keyword">String</span> doInBackground(<span class="keyword">String</span>... strings) {

 <span class="keyword">try</span> {
     client=<span class="keyword">new</span> DefaultHttpClient();
     httpGet=<span class="keyword">new</span> HttpGet(url);
    httpResponse= client.execute(httpGet);
    entity= httpResponse.getEntity();
     InputStream is=entity.getContent();
     InputStreamReader isr=<span class="keyword">new</span> InputStreamReader(is);
     <span class="keyword">BufferedReader</span> br=<span class="keyword">new</span> <span class="keyword">BufferedReader</span>(isr);
     <span class="keyword">String</span> <span class="built_in">line</span>;
     StringBuffer sb=<span class="keyword">new</span> StringBuffer();
     <span class="keyword">while</span> ((<span class="built_in">line</span>=br.readLine())!=<span class="keyword">null</span>){
         sb.<span class="built_in">append</span>(<span class="built_in">line</span>);
     }
     <span class="keyword">return</span> sb.toString();
 } <span class="keyword">catch</span> (IOException e) {
     e.printStackTrace();
 }
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/07/20/2015-7-20/" data-id="cieb6up6b001atob2dp16h2rz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


    
      <article id="post-2015-7-18-adapter" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/19/2015-7-18-adapter/">adapter</a>
    </h1>
  

        <div class="article-meta">
          <div class="article-date">
  <i class="fa fa-calendar"></i>
  <a href="/2015/07/19/2015-7-18-adapter/">
    <time datetime="2015-07-19T05:10:37.000Z" itemprop="datePublished">2015-07-19</time>
  </a>
</div>
          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Adapter">Adapter</h1><h2 id="Adapter的概念">Adapter的概念</h2><p> Adapter是连接后端数据和前端显示的适配器接口，是数据和UI（View）之间一个重要的纽带。在常见的View(List View,Grid View)等地方都需要用到Adapter。如下图直观的表达了Data、Adapter、View三者的关系：</p>
<h2 id="常用Adapter">常用Adapter</h2><ul>
<li>BaseAdapter是一个抽象类，继承它需要实现较多的方法，所以也就具有较高的灵活性；</li>
<li>ArrayAdapter支持泛型操作，最为简单，只能展示一行字。</li>
<li>SimpleAdapter有最好的扩充性，可以自定义出各种效果。</li>
<li>SimpleCursorAdapter可以适用于简单的纯文字型ListView，它需要Cursor的字段和UI的id对应起来。如需要实现更复杂的UI也可以重写其他方法。可以认为是SimpleAdapter对数据库的简单结合，可以方便地把数据库的内容以列表的形式展示出来。</li>
</ul>
<h2 id="ArrayAdapter的操作">ArrayAdapter的操作</h2><p>ArrayAdapter的操作很简单，构建一个ArrayAdapter（）实例。其中要传入三个参数。</p>
<p>依次为this,布局文件（注意这里的布局文件描述的是列表的每一行的布局，android.R.layout.simple_list_item_1是系统定义好的布局文件只显示一行文字，数据源(一个List集合)。</p>
<p>最后绑定显示。</p>
<pre><code>package com.zsz.develop.adaptertest;

<span class="keyword">import</span> android.app.ListActivity;
<span class="keyword">import</span> android.support.v7.app.ActionBarActivity;
<span class="keyword">import</span> android.os.Bundle;
<span class="keyword">import</span> android.view.Menu;
<span class="keyword">import</span> android.view.MenuItem;
<span class="keyword">import</span> android.widget.Adapter;
<span class="keyword">import</span> android.widget.ArrayAdapter;
<span class="keyword">import</span> android.widget.ListView;

<span class="keyword">import</span> java.util.ArrayList;


public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">ActionBarActivity</span> </span>{

private ListView lv;
private ArrayList&lt;<span class="built_in">String</span>&gt; mArrayList = <span class="keyword">new</span> ArrayList&lt;<span class="built_in">String</span>&gt;();
@Override
protected <span class="keyword">void</span> onCreate(Bundle savedInstanceState) {
    <span class="keyword">super</span>.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    ArrayAdapter&lt;<span class="built_in">String</span>&gt; adapter=<span class="keyword">new</span> ArrayAdapter&lt;<span class="built_in">String</span>&gt;(<span class="keyword">this</span>,android.R.layout.simple_list_item_1,getData());
    lv= (ListView) findViewById(R.id.lv);
    lv.setAdapter(adapter);

}
private ArrayList&lt;<span class="built_in">String</span>&gt; getData(){

    mArrayList.add(<span class="string">"测试一"</span>);
    mArrayList.add(<span class="string">"测试二"</span>);
    mArrayList.add(<span class="string">"测试三"</span>);
    mArrayList.add(<span class="string">"测试死"</span>);
    <span class="keyword">return</span> mArrayList;

}



}
</code></pre><h2 id="java与Mysql类型对应">java与Mysql类型对应</h2><p><img src="http://cl.ly/image/1k1z2h033V2O/QL" alt="">TTDB2<a href="RH(0A]8QQRR.png">N</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/07/19/2015-7-18-adapter/" data-id="cieb6up6g001ctob26cm8eitc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


    
      <article id="post-2015-7-18" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/18/2015-7-18/">ListView设置，相对位置，inflater 用法</a>
    </h1>
  

        <div class="article-meta">
          <div class="article-date">
  <i class="fa fa-calendar"></i>
  <a href="/2015/07/18/2015-7-18/">
    <time datetime="2015-07-18T14:16:28.000Z" itemprop="datePublished">2015-07-18</time>
  </a>
</div>
          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="7-18日问题集">7.18日问题集</h1><h2 id="ListView_可滚动与间隔设置">ListView 可滚动与间隔设置</h2><p>1.可滚动设置：transcriptMode<br>2.间隔设置：divider</p>
<pre><code>&lt;ListView
    android:<span class="variable">layout_width=</span><span class="string">"fill_parent"</span>
    android:<span class="variable">layout_height=</span><span class="string">"0dp"</span>
    android:<span class="variable">layout_weight=</span><span class="string">"1"</span>
    android:<span class="variable">transcriptMode=</span><span class="string">"alwaysScroll"</span>
    android:<span class="variable">divider=</span><span class="string">"@null"</span>
    &gt;&lt;/ListView&gt;
</code></pre><h2 id="图片设置内边距padding">图片设置内边距padding</h2><p>图片对其方式：layout_alignParentRight</p>
<pre><code>&lt;ImageView
     android:<span class="variable">layout_alignParentRight=</span><span class="string">"true"</span>
    android:<span class="variable">layout_width=</span><span class="string">"70dp"</span>
    android:<span class="variable">layout_height=</span><span class="string">"70dp"</span>
    android:<span class="variable">padding=</span><span class="string">"10dp"</span>
    android:<span class="variable">id=</span><span class="string">"@+id/iv"</span>
    android:<span class="variable">src=</span><span class="string">"@drawable/robot"</span>
    /&gt;
</code></pre><h2 id="设置相对位置">设置相对位置</h2><p>如设置textview的右边：layout_toRightOf<br>设置与有边框的距离：android:layout_marginRight=”50dp”<br>设置在谁的下面：android:layout_below=”@+id/time”</p>
<pre><code>&lt;TextView
    android:<span class="variable">layout_below=</span><span class="string">"@+id/time"</span>
    android:<span class="variable">layout_marginRight=</span><span class="string">"50dp"</span>
    android:<span class="variable">layout_toRightOf=</span><span class="string">"@+id/iv"</span>
    android:<span class="variable">layout_width=</span><span class="string">"wrap_content"</span>
    android:<span class="variable">layout_height=</span><span class="string">"wrap_content"</span>
    android:<span class="variable">id=</span><span class="string">"@+id/tv"</span>
    android:<span class="variable">background=</span><span class="string">"@drawable/aio_friend_bg_nor_11"</span>
    android:<span class="variable">gravity=</span><span class="string">"center"</span>
    /&gt;
</code></pre><h2 id="android_inflater_用法">android inflater 用法</h2><p>在实际开发中LayoutInflater这个类还是非常有用的，它的作用类似于findViewById()。不同点是LayoutInflater是用来找res/layout/下的xml布局文件，并且实例化；而findViewById()是找xml布局文件下的具体widget控件(如Button、TextView等)。 具体作用： 1、对于一个没有被载入或者想要动态载入的界面，都需要使用LayoutInflater.inflate()来载入；</p>
<p>2、对于一个已经载入的界面，就可以使用Activiyt.findViewById()方法来获得其中的界面元素。</p>
<p>LayoutInflater 是一个抽象类，在文档中如下声明：</p>
<p>publicabstractclass LayoutInflater extends Object </p>
<p>获得 LayoutInflater 实例的三种方式</p>
<p>1.LayoutInflater inflater = getLayoutInflater();  //调用Activity的getLayoutInflater()</p>
<p>2.LayoutInflater localinflater =(LayoutInflater)context.getSystemService</p>
<pre><code><span class="list">(<span class="keyword">Context.LAYOUT_INFLATER_SERVICE</span>)</span><span class="comment">;</span>
</code></pre><ol>
<li>LayoutInflater inflater = LayoutInflater.from(context);</li>
</ol>
<h2 id="-9图片">.9图片</h2><h2 id="adapter-notifyDataSetChanged();Adapter设置更改">adapter.notifyDataSetChanged();Adapter设置更改</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/07/18/2015-7-18/" data-id="cieb6up6e001btob2wiikps1u" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


    
      <article id="post-2015-7-15" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/15/2015-7-15/">Android通过httpClient获取网络请求，响应状态码含义，Http请求时要添加权限</a>
    </h1>
  

        <div class="article-meta">
          <div class="article-date">
  <i class="fa fa-calendar"></i>
  <a href="/2015/07/15/2015-7-15/">
    <time datetime="2015-07-15T00:50:03.000Z" itemprop="datePublished">2015-07-15</time>
  </a>
</div>
          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Android通过httpClient获取网络请求">Android通过httpClient获取网络请求</h1><p>在HttpClient模块中用到了两个重要的类：HttpGet和HttpPost。这两个类分别用来提交HTTP GET和HTTP POST请求。</p>
<p>无论是使用HttpGet，还是使用HttpPost，都必须通过如下3步来访问HTTP资源。</p>
<ul>
<li>1.创建HttpGet或HttpPost对象，将要请求的URL通过构造方法传入HttpGet或HttpPost对象。</li>
<li>2.使用DefaultHttpClient类的execute方法发送HTTP GET或HTTP POST请求，并返回HttpResponse对象。</li>
<li>3.通过HttpResponse接口的getEntity方法返回响应信息，并进行相应的处理。（判断请求响应状态码，状态码为200表示服务端成功响应了客户端的请求。</li>
</ul>
<h2 id="响应状态码含义">响应状态码含义</h2><ul>
<li>◆200 (OK): 找到了该资源，并且一切正常。</li>
<li>◆304 (NOT MODIFIED): 该资源在上次请求之后没有任何修改。这通常用于浏览器的缓存机制。</li>
<li>◆401 (UNAUTHORIZED): 客户端无权访问该资源。这通常会使得浏览器要求用户输入用户名和密码，以登录到服务器。</li>
<li>◆403 (FORBIDDEN): 客户端未能获得授权。这通常是在401之后输入了不正确的用户名或密码。</li>
<li>◆404 (NOT FOUND): 在指定的位置不存在所申请的资源。<br>）。</li>
</ul>
<h2 id="Http请求时要添加权限！！！">Http请求时要添加权限！！！</h2><p>找了一下午真是活该！<br>没加权限竟然。</p>
<pre><code><span class="number">07</span>-<span class="number">18</span> <span class="number">09</span>:<span class="number">05</span>:<span class="number">31.824</span>    <span class="number">1781</span>-<span class="number">1794</span>/com<span class="class">.zsz</span><span class="class">.develop</span><span class="class">.myrobot</span> E/AndroidRuntime﹕ FATAL EXCEPTION: AsyncTask #<span class="number">1</span>
java<span class="class">.lang</span><span class="class">.RuntimeException</span>: An error occured while executing <span class="function"><span class="title">doInBackground</span><span class="params">()</span></span>
</code></pre><p>错误行数在</p>
<pre><code><span class="attribute">httpResponse</span>=<span class="string"> httpClient.execute(httpGet);</span>
</code></pre><p>和</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">HttpData</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AsyncTask&lt;String</span>, <span class="title">Void</span>, <span class="title">String&gt;</span> {</span>
</code></pre><p>下回涨点记性</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/07/15/2015-7-15/" data-id="cieb6up6i001dtob2bcqgudn9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


    
      <article id="post-2015-7-13-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/13/2015-7-13-2/">获取上下文路径，get和post</a>
    </h1>
  

        <div class="article-meta">
          <div class="article-date">
  <i class="fa fa-calendar"></i>
  <a href="/2015/07/13/2015-7-13-2/">
    <time datetime="2015-07-13T09:09:29.000Z" itemprop="datePublished">2015-07-13</time>
  </a>
</div>
          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="问题集">问题集</h1><h2 id="request-getContextPath()获取上下文路径">request.getContextPath()获取上下文路径</h2><p>超级实用的小技巧</p>
<p>《form action=”&lt;%=request.getContextPath() %&gt;/loginServlet” method=”post”&gt;</p>
<h2 id="Servlet添加到web。xml中的信息">Servlet添加到web。xml中的信息</h2><p>其中url中的值要与上面相对应。<br>    <servlet><br>          <servlet-name>LoginServlet</servlet-name><br>          <servlet-class>com.zsz.develop.servlet.LoginServlet</servlet-class><br>      </servlet></p>
<pre><code><span class="tag">&lt;<span class="title">servlet-mapping</span>&gt;</span>
    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>LoginServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/loginServlet<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span>
<span class="tag">&lt;/<span class="title">servlet-mapping</span>&gt;</span>
</code></pre><h2 id="get和post">get和post</h2><p><img src="http://cl.ly/image/2A2O3e2H3v27/E%7BKO]~HE348]90%252~9%7D9HGS.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/07/13/2015-7-13-2/" data-id="cieb6up6n001ftob2oxpsaiy4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


    
      <article id="post-2015-7-13" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/12/2015-7-13/">JDBC API，JDBC Driver API，JDBC的操作流程，事务的四个特征，JDBC事务处理</a>
    </h1>
  

        <div class="article-meta">
          <div class="article-date">
  <i class="fa fa-calendar"></i>
  <a href="/2015/07/12/2015-7-13/">
    <time datetime="2015-07-12T11:31:21.000Z" itemprop="datePublished">2015-07-12</time>
  </a>
</div>
          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="7-13日问题集">7.13日问题集</h1><h2 id="JDBC_API">JDBC API</h2><p>DriverManager：这是一个驱动程序管理类，用来装载驱动程序。并为创建数据库连接提供支持</p>
<ul>
<li><p>Connection：connection是一个接口，用来连接某一特定的数据库。</p>
</li>
<li><p>Statement：statement接口提供了执行SQL语句。获取查询结果的方法</p>
</li>
<li><p>PreparedStatement：是statement的子接口，用来执行编译的sql语句</p>
</li>
<li><p>ResultSet：该接口提供了对结果集的处理方法</p>
</li>
</ul>
<h2 id="JDBC_Driver_API">JDBC Driver API</h2><p>JDBC Driver API是面向驱动程序开发商的接口</p>
<p>主要有四种:</p>
<ul>
<li>JDBC-ODBC bridge：这种驱动程序会把jdbc的调用委托给其他接口</li>
<li>部分java技术的本地api驱动程序</li>
<li>全部基于java技术的本地api驱动程序</li>
<li>全部基于java技术的本地协议驱动程序</li>
</ul>
<h2 id="JDBC的操作流程">JDBC的操作流程</h2><p><img src="http://cl.ly/image/0X0q2w0F3l2M/Image%202015-07-13%20at%201.38.03%20%E4%B8%8B%E5%8D%88.png" alt=""></p>
<h2 id="Class-forName（）">Class.forName（）</h2><p>Class：这个类封装了要装载到JVM中类的信息。比如类的成员方法，成员变量，以及这个类实现的接口。</p>
<p>forName（）：这个方法用来初始化指定参数的类。并创建一个对应的实例对象</p>
<p>参数中的字符串：是mysql指定的字符串驱动程序</p>
<h2 id="事务的四个特征">事务的四个特征</h2><p>事务是作为一个逻辑单元执行的一系列操作，一个逻辑工作单元必须有四个属性，称为 ACID（原子性、一致性、隔离性和持久性）属性，只有这样才能成为一个事务：</p>
<ul>
<li><p>原子性<br>事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。</p>
</li>
<li><p>一致性<br>事务在完成时，必须使所有的数据都保持一致状态。在相关数据库中，所有规则都必须应用于事务的修改，以保持所有数据的完整性。事务结束时，所有的内部数据结构（如 B 树索引或双向链表）都必须是正确的。</p>
</li>
<li><p>隔离性<br>由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看中间状态的数据。这称为可串行性，因为它能够重新装载起始数据，并且重播一系列事务，以使数据结束时的状态与原始事务执行的状态相同。</p>
</li>
<li><p>持久性<br>事务完成之后，它对于系统的影响是永久性的。该修改即使出现系统故障也将一直保持。</p>
</li>
</ul>
<h2 id="JDBC事务处理">JDBC事务处理</h2><p><a href="http://blog.csdn.net/csc0211/article/details/6232047" title="JDBC事务处理" target="_blank" rel="external">http://blog.csdn.net/csc0211/article/details/6232047</a></p>
<blockquote>
<p>在JDBC的数据库操作中，一项事务是由一条或是多条表达式所组成的一个不可分割的工作单元。我们通过提交commit()或是回退rollback()来结束事务的操作。关于事务操作的方法都位于接口java.sql.Connection中。</p>
<p>首先我们要注意，在JDBC中，事务操作默认是自动提交。也就是说，一条对数据库的更新表达式代表一项事务操作。操作成功后，系统将自动调用commit()来提交，否则将调用rollback()来回退。<br>    其次，在JDBC中，可以通过调用setAutoCommit(false)来禁止自动提交。之后就可以把多个数据库操作的表达式作为一个事务，在操作完成后调用commit()来进行整体提交。倘若其中一个表达式操作失败，都不会执行到commit()，并且将产生响应的异常。此时就可以在异常捕获时调用rollback()进行回退。这样做可以保持多次更新操作后，相关数据的一致性。<br>    具体事例如下：</p>
</blockquote>
<pre><code>        <span class="keyword">try</span> {
    <span class="keyword">Class</span>.forName(<span class="string">"oracle.jdbc.driver.OracleDriver"</span>);
    conn = DriverManager.getConnection(<span class="string">"jdbc:oracle:thin:@127.0.0.1:1521:luecc"</span>, <span class="string">"scott"</span>, <span class="string">"tiger"</span>);
                <span class="comment">//点禁止自动提交，设置回退</span>
    conn.setAutoCommit(<span class="keyword">false</span>);
    stmt = conn.createStatement();
                <span class="comment">//数据更新</span>
    stmt.addBatch(<span class="string">"insert into dept values (51, '500', 'ccc')"</span>);
    stmt.addBatch(<span class="string">"insert into dept values (52, '600', 'ddd')"</span>);
    stmt.addBatch(<span class="string">"insert into dept values (53, '700', 'eee')"</span>);
    stmt.executeBatch();
                <span class="comment">//事务提交 </span>
    conn.commit();
    conn.setAutoCommit(<span class="keyword">true</span>);
} <span class="keyword">catch</span> (ClassNotFoundException e) {
    e.printStackTrace();
} <span class="keyword">catch</span>(SQLException e) {
    e.printStackTrace();
    <span class="keyword">try</span> {
        <span class="keyword">if</span>(conn != <span class="keyword">null</span>)
        {
                                <span class="comment">//操作不成功则回退</span>
            conn.rollback();
                                <span class="comment">//重新设置恢复默认值</span>
            conn.setAutoCommit(<span class="keyword">true</span>);
        }
    } <span class="keyword">catch</span> (SQLException e1) {
        e1.printStackTrace();
    }
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/07/12/2015-7-13/" data-id="cieb6up6l001etob2vsy0asmo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


    
      <nav id="page-nav">
        <a class="extend prev" rel="prev" href="/page/4/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/6/">Next &raquo;</a>
      </nav>
    </section>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 zszdevelop<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="http://github.com/ppoffice">PPOffice</a>
    </div>
  </div>
</footer>
    


<script src="//ajax.useso.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>